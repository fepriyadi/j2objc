//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/guava/android/build_result/java/com/google/common/util/concurrent/ClosingFuture.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture")
#ifdef RESTRICT_ComGoogleCommonUtilConcurrentClosingFuture
#define INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture 0
#else
#define INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture 1
#endif
#undef RESTRICT_ComGoogleCommonUtilConcurrentClosingFuture
#ifdef INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner5
#define INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner 1
#endif
#ifdef INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner4
#define INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner 1
#endif
#ifdef INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner3
#define INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner 1
#endif
#ifdef INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner2
#define INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner 1
#endif

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture))
#define ComGoogleCommonUtilConcurrentClosingFuture_

@class ComGoogleCommonUtilConcurrentClosingFuture_Combiner2;
@class ComGoogleCommonUtilConcurrentClosingFuture_Combiner3;
@class ComGoogleCommonUtilConcurrentClosingFuture_Combiner4;
@class ComGoogleCommonUtilConcurrentClosingFuture_Combiner5;
@class ComGoogleCommonUtilConcurrentClosingFuture_Combiner;
@class ComGoogleCommonUtilConcurrentFluentFuture;
@class IOSClass;
@class IOSObjectArray;
@class JavaUtilConcurrentCountDownLatch;
@protocol ComGoogleCommonUtilConcurrentAsyncFunction;
@protocol ComGoogleCommonUtilConcurrentClosingFuture_AsyncClosingFunction;
@protocol ComGoogleCommonUtilConcurrentClosingFuture_ClosingCallable;
@protocol ComGoogleCommonUtilConcurrentClosingFuture_ClosingFunction;
@protocol ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloserConsumer;
@protocol ComGoogleCommonUtilConcurrentListenableFuture;
@protocol JavaLangIterable;
@protocol JavaUtilConcurrentExecutor;

/*!
 @brief A step in a pipeline of an asynchronous computation.When the last step in the computation is
  complete, some objects captured during the computation are closed.
 <p>A pipeline of <code>ClosingFuture</code>s is a tree of steps. Each step represents either an
  asynchronously-computed intermediate value, or else an exception that indicates the failure or
  cancellation of the operation so far. The only way to extract the value or exception from a step
  is by declaring that step to be the last step of the pipeline. Nevertheless, we refer to the
  "value" of a successful step or the "result" (value or exception) of any step. 
 <ol>
    <li>A pipeline starts at its leaf step (or steps), which is created from either a callable
        block or a <code>ListenableFuture</code>.
    <li>Each other step is derived from one or more input steps. At each step, zero or more objects
        can be captured for later closing.   
 <li>There is one last step (the root of the tree), from which you can extract the final result
        of the computation. After that result is available (or the computation fails), all objects
        captured by any of the steps in the pipeline are closed. 
 </ol>
  
 <h3>Starting a pipeline</h3>
  Start a <code>ClosingFuture</code> pipeline from a
  callable block
  that may capture objects for later closing. To start a pipeline from a <code>ListenableFuture</code>
  that doesn't create resources that should be closed later, you can use <code>from(ListenableFuture)</code>
  instead. 
 <h3>Derived steps</h3>
  A <code>ClosingFuture</code> step can be derived from one or more input <code>ClosingFuture</code> steps in
  ways similar to <code>FluentFuture</code>s:
  
 <ul>
    <li>by transforming the value from a successful input step,
    <li>by catching the exception from a failed input step, or
    <li>by combining the results of several input steps. 
 </ul>
  Each derivation can capture the next value or any intermediate objects for later closing. 
 <p>A step can be the input to at most one derived step. Once you transform its value, catch its
  exception, or combine it with others, you cannot do anything else with it, including declare it
  to be the last step of the pipeline. 
 <h4>Transforming</h4>
  To derive the next step by asynchronously applying a function to an input step's value, call 
 <code>transform(ClosingFunction, Executor)</code> or <code>transformAsync(AsyncClosingFunction,
 Executor)</code>
  on the input step. 
 <h4>Catching</h4>
  To derive the next step from a failed input step, call <code>catching(Class, ClosingFunction,
 Executor)</code>
  or <code>catchingAsync(Class, AsyncClosingFunction, Executor)</code> on the input step. 
 <h4>Combining</h4>
  To derive a <code>ClosingFuture</code> from two or more input steps, pass the input steps to <code>whenAllComplete(Iterable)</code>
  or <code>whenAllSucceed(Iterable)</code> or its overloads. 
 <h3>Cancelling</h3>
  Any step in a pipeline can be cancelled, even after another step
  has been derived, with the same semantics as cancelling a <code>Future</code>. In addition, a
  successfully cancelled step will immediately start closing all objects captured for later closing
  by it and by its input steps. 
 <h3>Ending a pipeline</h3>
  Each <code>ClosingFuture</code> pipeline must be ended. To end a pipeline, decide whether you want to
  close the captured objects automatically or manually. 
 <h4>Automatically closing</h4>
  You can extract a <code>Future</code> that represents the result of the last step in the pipeline by
  calling <code>finishToFuture()</code>. When that final <code>Future</code> is done, all objects captured
  by all steps in the pipeline will be closed. 
 @code
 FluentFuture<UserName> userName =
      ClosingFuture.submit(
              closer -> closer.eventuallyClose(database.newTransaction(), closingExecutor),
              executor)
          .transformAsync((closer, transaction) -> transaction.queryClosingFuture("..."), executor)
          .transform((closer, result) -> result.get("userName"), directExecutor())
          .catching(DBException.class, e -> "no user", directExecutor())
          .finishToFuture(); 
 
@endcode
  In this example, when the <code>userName</code> <code>Future</code> is done, the transaction and the query
  result cursor will both be closed, even if the operation is cancelled or fails. 
 <h4>Manually closing</h4>
  If you want to close the captured objects manually, after you've used the final result, call 
 <code>finishToValueAndCloser(ValueAndCloserConsumer, Executor)</code> to get an object that holds the
  final result. You then call <code>ValueAndCloser.closeAsync()</code> to close the captured objects. 
 @code
    ClosingFuture.submit(
              closer -> closer.eventuallyClose(database.newTransaction(), closingExecutor),
              executor)
      .transformAsync((closer, transaction) -> transaction.queryClosingFuture("..."), executor)
      .transform((closer, result) -> result.get("userName"), directExecutor())
      .catching(DBException.class, e -> "no user", directExecutor())
      .finishToValueAndCloser(
          valueAndCloser -> this.userNameValueAndCloser = valueAndCloser, executor);
  // later
  try { // get() will throw if the operation failed or was cancelled.
    UserName userName = userNameValueAndCloser.get();
    // do something with userName
  } finally {
    userNameValueAndCloser.closeAsync();
  } 
 
@endcode
  In this example, when <code>userNameValueAndCloser.closeAsync()</code> is called, the transaction and
  the query result cursor will both be closed, even if the operation is cancelled or fails. 
 <p>Note that if you don't call <code>closeAsync()</code>, the captured objects will not be closed. The
  automatic-closing approach described above is safer.
 @since 30.0
 */
@interface ComGoogleCommonUtilConcurrentClosingFuture : NSObject

#pragma mark Public

/*!
 @brief Attempts to cancel execution of this step.This attempt will fail if the step has already
  completed, has already been cancelled, or could not be cancelled for some other reason.
 If
  successful, and this step has not started when <code>cancel</code> is called, this step should never
  run. 
 <p>If successful, causes the objects captured by this step (if already started) and its input
  step(s) for later closing to be closed on their respective <code>Executor</code>s. If any such calls
  specified <code>MoreExecutors.directExecutor()</code>, those objects will be closed synchronously.
 @param mayInterruptIfRunning<code>true</code>  if the thread executing this task should be      interrupted; otherwise, in-progress tasks are allowed to complete, but the step will be
       cancelled regardless
 @return <code>false</code> if the step could not be cancelled, typically because it has already
      completed normally; <code>true</code> otherwise
 */
- (jboolean)cancelWithBoolean:(jboolean)mayInterruptIfRunning;

/*!
 @brief Returns a new <code>ClosingFuture</code> pipeline step derived from this one by applying a function
  to its exception if it is an instance of a given exception type.The function can use a <code>DeferredCloser</code>
  to capture objects to be closed when the pipeline is done.
 <p>If this <code>ClosingFuture</code> succeeds or fails with a different exception type, the
  function will not be called, and the derived <code>ClosingFuture</code> will be equivalent to this
  one. 
 <p>If the function throws an exception, that exception is used as the result of the derived 
 <code>ClosingFuture</code>.
  
 <p>Example usage: 
 @code
 ClosingFuture<QueryResult> queryFuture =
      queryFuture.catching(
          QueryException.class, (closer, x) -> Query.emptyQueryResult(), executor); 
 
@endcode
  
 <p>When selecting an executor, note that <code>directExecutor</code> is dangerous in some cases. See
  the discussion in the <code>ListenableFuture.addListener</code> documentation. All its warnings
  about heavyweight listeners are also applicable to heavyweight functions passed to this method. 
 <p>After calling this method, you may not call <code>finishToFuture()</code>, <code>finishToValueAndCloser(ValueAndCloserConsumer, Executor)</code>
 , or any other derivation method on
  this <code>ClosingFuture</code>.
 @param exceptionType the exception type that triggers use of <code>fallback</code> . The exception
       type is matched against this step's exception. "This step's exception" means the cause of      the 
 <code>ExecutionException</code>  thrown by <code>Future.get()</code>  on the <code>Future</code>      underlying this step or, if 
 <code>get()</code>  throws a different kind of exception, that      exception itself. To avoid hiding bugs and other unrecoverable errors, callers should
       prefer more specific types, avoiding 
 <code>Throwable.class</code>  in particular.
 @param fallback the function to be called if this step fails with the expected exception type.      The function's argument is this step's exception. "This step's exception" means the cause
       of the 
 <code>ExecutionException</code>  thrown by <code>Future.get()</code>  on the <code>Future</code>      underlying this step or, if 
 <code>get()</code>  throws a different kind of exception, that      exception itself.
 @param executor the executor that runs <code>fallback</code>  if the input fails
 */
- (ComGoogleCommonUtilConcurrentClosingFuture *)catchingWithIOSClass:(IOSClass * __nonnull)exceptionType
      withComGoogleCommonUtilConcurrentClosingFuture_ClosingFunction:(id<ComGoogleCommonUtilConcurrentClosingFuture_ClosingFunction> __nonnull)fallback
                                      withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

/*!
 @brief Returns a new <code>ClosingFuture</code> pipeline step derived from this one by applying a function
  that returns a <code>ClosingFuture</code> to its exception if it is an instance of a given exception
  type.The function can use a <code>DeferredCloser</code> to capture objects to be closed when the
  pipeline is done (other than those captured by the returned <code>ClosingFuture</code>).
 <p>If this <code>ClosingFuture</code> fails with an exception of the given type, the derived <code>ClosingFuture</code>
  will be equivalent to the one returned by the function. 
 <p>If this <code>ClosingFuture</code> succeeds or fails with a different exception type, the
  function will not be called, and the derived <code>ClosingFuture</code> will be equivalent to this
  one. 
 <p>If the function throws an exception, that exception is used as the result of the derived 
 <code>ClosingFuture</code>. But if the exception is thrown after the function creates a <code>ClosingFuture</code>
 , then none of the closeable objects in that <code>ClosingFuture</code> will be
  closed. 
 <p>Usage guidelines for this method: 
 <ul>
    <li>Use this method only when calling an API that returns a <code>ListenableFuture</code> or a
        <code>ClosingFuture</code>. If possible, prefer calling <code>catching(Class,
       ClosingFunction, Executor)</code>
  instead, with a function that returns the next value
        directly.   
 <li>Call <code>closer.eventuallyClose()</code>
        for every closeable object this step creates in order to capture it for later closing.   
 <li>Return a <code>ClosingFuture</code>. To turn a <code>ListenableFuture</code> into a <code>ClosingFuture</code>
  call <code>from(ListenableFuture)</code>.
    <li>In case this step doesn't create new closeables, you can adapt an API that returns a
        <code>ListenableFuture</code> to return a <code>ClosingFuture</code> by wrapping it with a call to
        <code>withoutCloser(AsyncFunction)</code>
  </ul>
  
 <p>Example usage: 
 @code
 // Fall back to a secondary input stream in case of IOException.
  ClosingFuture<InputStream> inputFuture =
      firstInputFuture.catchingAsync(
          IOException.class, (closer, x) -> secondaryInputStreamClosingFuture(), executor); 
  }
@endcode
  
 <p>When selecting an executor, note that <code>directExecutor</code> is dangerous in some cases. See
  the discussion in the <code>ListenableFuture.addListener</code> documentation. All its warnings
  about heavyweight listeners are also applicable to heavyweight functions passed to this method.
  (Specifically, <code>directExecutor</code> functions should avoid heavyweight operations inside 
 <code>AsyncClosingFunction.apply</code>. Any heavyweight operations should occur in other threads
  responsible for completing the returned <code>ClosingFuture</code>.)
  
 <p>After calling this method, you may not call <code>finishToFuture()</code>, <code>finishToValueAndCloser(ValueAndCloserConsumer, Executor)</code>
 , or any other derivation method on
  this <code>ClosingFuture</code>.
 @param exceptionType the exception type that triggers use of <code>fallback</code> . The exception
       type is matched against this step's exception. "This step's exception" means the cause of      the 
 <code>ExecutionException</code>  thrown by <code>Future.get()</code>  on the <code>Future</code>      underlying this step or, if 
 <code>get()</code>  throws a different kind of exception, that      exception itself. To avoid hiding bugs and other unrecoverable errors, callers should
       prefer more specific types, avoiding 
 <code>Throwable.class</code>  in particular.
 @param fallback the function to be called if this step fails with the expected exception type.      The function's argument is this step's exception. "This step's exception" means the cause
       of the 
 <code>ExecutionException</code>  thrown by <code>Future.get()</code>  on the <code>Future</code>      underlying this step or, if 
 <code>get()</code>  throws a different kind of exception, that      exception itself.
 @param executor the executor that runs <code>fallback</code>  if the input fails
 */
- (ComGoogleCommonUtilConcurrentClosingFuture *)catchingAsyncWithIOSClass:(IOSClass * __nonnull)exceptionType
      withComGoogleCommonUtilConcurrentClosingFuture_AsyncClosingFunction:(id<ComGoogleCommonUtilConcurrentClosingFuture_AsyncClosingFunction> __nonnull)fallback
                                           withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

/*!
 @brief Starts a <code>ClosingFuture</code> pipeline with a <code>ListenableFuture</code>.
 <p>If <code>future</code> succeeds, its value will be closed (using <code>closingExecutor)</code> when
  the pipeline is done, even if the pipeline is canceled or fails. 
 <p>Cancelling the pipeline will not cancel <code>future</code>, so that the pipeline can access its
  value in order to close it.
 @param future the future to create the <code>ClosingFuture</code>  from. For discussion of the
       future's result type <code>C</code> , see <code>DeferredCloser.eventuallyClose(Closeable,
     Executor)</code>
  .
 @param closingExecutor the future's result will be closed on this executor
 */
+ (ComGoogleCommonUtilConcurrentClosingFuture *)eventuallyClosingWithComGoogleCommonUtilConcurrentListenableFuture:(id<ComGoogleCommonUtilConcurrentListenableFuture> __nonnull)future
                                                                                    withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)closingExecutor __attribute__((deprecated));

/*!
 @brief Marks this step as the last step in the <code>ClosingFuture</code> pipeline.When the returned 
 <code>Future</code> is done, all objects captured for closing during the pipeline's computation will
  be closed.
 <p>After calling this method, you may not call <code>finishToValueAndCloser(ValueAndCloserConsumer, Executor)</code>
 , this method, or any other
  derivation method on this <code>ClosingFuture</code>.
 @return a <code>Future</code> that represents the final value or exception of the pipeline
 */
- (ComGoogleCommonUtilConcurrentFluentFuture *)finishToFuture;

/*!
 @brief Marks this step as the last step in the <code>ClosingFuture</code> pipeline.When this step is done, 
 <code>receiver</code> will be called with an object that contains the result of the operation.
 The
  receiver can store the <code>ValueAndCloser</code> outside the receiver for later synchronous use. 
 <p>After calling this method, you may not call <code>finishToFuture()</code>, this method again, or
  any other derivation method on this <code>ClosingFuture</code>.
 @param consumer a callback whose method will be called (using <code>executor</code> ) when this
       operation is done
 */
- (void)finishToValueAndCloserWithComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloserConsumer:(id<ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloserConsumer> __nonnull)consumer
                                                                     withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

/*!
 @brief Starts a <code>ClosingFuture</code> pipeline with a <code>ListenableFuture</code>.
 <p><code>future</code>'s value will not be closed when the pipeline is done even if <code>V</code>
  implements <code>Closeable</code>. In order to start a pipeline with a value that will be closed
  when the pipeline is done, use <code>submit(ClosingCallable, Executor)</code> instead.
 */
+ (ComGoogleCommonUtilConcurrentClosingFuture *)fromWithComGoogleCommonUtilConcurrentListenableFuture:(id<ComGoogleCommonUtilConcurrentListenableFuture> __nonnull)future;

/*!
 @brief Returns a future that finishes when this step does.Calling <code>get()</code> on the returned
  future returns <code>null</code> if the step is successful or throws the same exception that would
  be thrown by calling <code>finishToFuture().get()</code> if this were the last step.
 Calling <code>cancel()</code>
  on the returned future has no effect on the <code>ClosingFuture</code> pipeline. 
 <p><code>statusFuture</code> differs from most methods on <code>ClosingFuture</code>: You can make calls
  to <code>statusFuture</code> <i>in addition to</i> the call you make to <code>finishToFuture()</code> or
  a derivation method <i>on the same instance</i>. This is important because calling <code>statusFuture</code>
  alone does not provide a way to close the pipeline.
 */
- (id<ComGoogleCommonUtilConcurrentListenableFuture>)statusFuture;

/*!
 @brief Starts a <code>ClosingFuture</code> pipeline by submitting a callable block to an executor.
 @throw java.util.concurrent.RejectedExecutionExceptionif the task cannot be scheduled for
      execution
 */
+ (ComGoogleCommonUtilConcurrentClosingFuture *)submitWithComGoogleCommonUtilConcurrentClosingFuture_ClosingCallable:(id<ComGoogleCommonUtilConcurrentClosingFuture_ClosingCallable> __nonnull)callable
                                                                                      withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

- (NSString *)description;

/*!
 @brief Returns a new <code>ClosingFuture</code> pipeline step derived from this one by applying a function
  to its value.The function can use a <code>DeferredCloser</code> to capture objects to be closed
  when the pipeline is done.
 <p>If this <code>ClosingFuture</code> fails, the function will not be called, and the derived <code>ClosingFuture</code>
  will be equivalent to this one. 
 <p>If the function throws an exception, that exception is used as the result of the derived 
 <code>ClosingFuture</code>.
  
 <p>Example usage: 
 @code
 ClosingFuture<List<Row>> rowsFuture =
      queryFuture.transform((closer, result) -> result.getRows(), executor); 
 
@endcode
  
 <p>When selecting an executor, note that <code>directExecutor</code> is dangerous in some cases. See
  the discussion in the <code>ListenableFuture.addListener</code> documentation. All its warnings
  about heavyweight listeners are also applicable to heavyweight functions passed to this method. 
 <p>After calling this method, you may not call <code>finishToFuture()</code>, <code>finishToValueAndCloser(ValueAndCloserConsumer, Executor)</code>
 , or any other derivation method on
  this <code>ClosingFuture</code>.
 @param function transforms the value of this step to the value of the derived step
 @param executor executor to run the function in
 @return the derived step
 @throw IllegalStateExceptionif a <code>ClosingFuture</code> has already been derived from this
      one, or if this <code>ClosingFuture</code> has already been finished
 */
- (ComGoogleCommonUtilConcurrentClosingFuture *)transformWithComGoogleCommonUtilConcurrentClosingFuture_ClosingFunction:(id<ComGoogleCommonUtilConcurrentClosingFuture_ClosingFunction> __nonnull)function
                                                                                         withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

/*!
 @brief Returns a new <code>ClosingFuture</code> pipeline step derived from this one by applying a function
  that returns a <code>ClosingFuture</code> to its value.The function can use a <code>DeferredCloser</code>
  to capture objects to be closed when the pipeline is done (other than those
  captured by the returned <code>ClosingFuture</code>).
 <p>If this <code>ClosingFuture</code> succeeds, the derived one will be equivalent to the one
  returned by the function. 
 <p>If this <code>ClosingFuture</code> fails, the function will not be called, and the derived <code>ClosingFuture</code>
  will be equivalent to this one. 
 <p>If the function throws an exception, that exception is used as the result of the derived 
 <code>ClosingFuture</code>. But if the exception is thrown after the function creates a <code>ClosingFuture</code>
 , then none of the closeable objects in that <code>ClosingFuture</code> will be
  closed. 
 <p>Usage guidelines for this method: 
 <ul>
    <li>Use this method only when calling an API that returns a <code>ListenableFuture</code> or a
        <code>ClosingFuture</code>. If possible, prefer calling <code>transform(ClosingFunction,
       Executor)</code>
  instead, with a function that returns the next value directly.
    <li>Call <code>closer.eventuallyClose()</code>
        for every closeable object this step creates in order to capture it for later closing.   
 <li>Return a <code>ClosingFuture</code>. To turn a <code>ListenableFuture</code> into a <code>ClosingFuture</code>
  call <code>from(ListenableFuture)</code>.
    <li>In case this step doesn't create new closeables, you can adapt an API that returns a
        <code>ListenableFuture</code> to return a <code>ClosingFuture</code> by wrapping it with a call to
        <code>withoutCloser(AsyncFunction)</code>
  </ul>
  
 <p>Example usage: 
 @code
 // Result.getRowsClosingFuture() returns a ClosingFuture.
  ClosingFuture<List<Row>> rowsFuture =
      queryFuture.transformAsync((closer, result) -> result.getRowsClosingFuture(), executor);
  // Result.writeRowsToOutputStreamFuture() returns a ListenableFuture that resolves to the
  // number of written rows. openOutputFile() returns a FileOutputStream (which implements
  // Closeable).
  ClosingFuture<Integer> rowsFuture2 =
      queryFuture.transformAsync(
          (closer, result) -> {
            FileOutputStream fos = closer.eventuallyClose(openOutputFile(), closingExecutor);
            return ClosingFuture.from(result.writeRowsToOutputStreamFuture(fos));
       },
       executor);
  // Result.getRowsFuture() returns a ListenableFuture (no new closeables are created).
  ClosingFuture<List<Row>> rowsFuture3 =
      queryFuture.transformAsync(withoutCloser(Result::getRowsFuture), executor); 
 
@endcode
  
 <p>When selecting an executor, note that <code>directExecutor</code> is dangerous in some cases. See
  the discussion in the <code>ListenableFuture.addListener</code> documentation. All its warnings
  about heavyweight listeners are also applicable to heavyweight functions passed to this method.
  (Specifically, <code>directExecutor</code> functions should avoid heavyweight operations inside 
 <code>AsyncClosingFunction.apply</code>. Any heavyweight operations should occur in other threads
  responsible for completing the returned <code>ClosingFuture</code>.)
  
 <p>After calling this method, you may not call <code>finishToFuture()</code>, <code>finishToValueAndCloser(ValueAndCloserConsumer, Executor)</code>
 , or any other derivation method on
  this <code>ClosingFuture</code>.
 @param function transforms the value of this step to a <code>ClosingFuture</code>  with the value of
       the derived step
 @param executor executor to run the function in
 @return the derived step
 @throw IllegalStateExceptionif a <code>ClosingFuture</code> has already been derived from this
      one, or if this <code>ClosingFuture</code> has already been finished
 */
- (ComGoogleCommonUtilConcurrentClosingFuture *)transformAsyncWithComGoogleCommonUtilConcurrentClosingFuture_AsyncClosingFunction:(id<ComGoogleCommonUtilConcurrentClosingFuture_AsyncClosingFunction> __nonnull)function
                                                                                                   withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

/*!
 @brief Starts specifying how to combine <code>ClosingFuture</code>s into a single pipeline.
 @throw IllegalStateExceptionif a <code>ClosingFuture</code> has already been derived from any of
      the arguments, or if any has already been finished
 */
+ (ComGoogleCommonUtilConcurrentClosingFuture_Combiner *)whenAllCompleteWithComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future1
                                                                   withComGoogleCommonUtilConcurrentClosingFutureArray:(IOSObjectArray * __nonnull)moreFutures;

/*!
 @brief Starts specifying how to combine <code>ClosingFuture</code>s into a single pipeline.
 @throw IllegalStateExceptionif a <code>ClosingFuture</code> has already been derived from any of
      the <code>futures</code>, or if any has already been finished
 */
+ (ComGoogleCommonUtilConcurrentClosingFuture_Combiner *)whenAllCompleteWithJavaLangIterable:(id<JavaLangIterable> __nonnull)futures;

/*!
 @brief Starts specifying how to combine two <code>ClosingFuture</code>s into a single pipeline, assuming
  they all succeed.If any fail, the resulting pipeline will fail.
 <p>Calling this method allows you to use lambdas or method references typed with the types of
  the input <code>ClosingFuture</code>s.
 @throw IllegalStateExceptionif a <code>ClosingFuture</code> has already been derived from any of
      the arguments, or if any has already been finished
 */
+ (ComGoogleCommonUtilConcurrentClosingFuture_Combiner2 *)whenAllSucceedWithComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future1
                                                                        withComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future2;

/*!
 @brief Starts specifying how to combine three <code>ClosingFuture</code>s into a single pipeline, assuming
  they all succeed.If any fail, the resulting pipeline will fail.
 <p>Calling this method allows you to use lambdas or method references typed with the types of
  the input <code>ClosingFuture</code>s.
 @throw IllegalStateExceptionif a <code>ClosingFuture</code> has already been derived from any of
      the arguments, or if any has already been finished
 */
+ (ComGoogleCommonUtilConcurrentClosingFuture_Combiner3 *)whenAllSucceedWithComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future1
                                                                        withComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future2
                                                                        withComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future3;

/*!
 @brief Starts specifying how to combine four <code>ClosingFuture</code>s into a single pipeline, assuming
  they all succeed.If any fail, the resulting pipeline will fail.
 <p>Calling this method allows you to use lambdas or method references typed with the types of
  the input <code>ClosingFuture</code>s.
 @throw IllegalStateExceptionif a <code>ClosingFuture</code> has already been derived from any of
      the arguments, or if any has already been finished
 */
+ (ComGoogleCommonUtilConcurrentClosingFuture_Combiner4 *)whenAllSucceedWithComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future1
                                                                        withComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future2
                                                                        withComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future3
                                                                        withComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future4;

/*!
 @brief Starts specifying how to combine five <code>ClosingFuture</code>s into a single pipeline, assuming
  they all succeed.If any fail, the resulting pipeline will fail.
 <p>Calling this method allows you to use lambdas or method references typed with the types of
  the input <code>ClosingFuture</code>s.
 @throw IllegalStateExceptionif a <code>ClosingFuture</code> has already been derived from any of
      the arguments, or if any has already been finished
 */
+ (ComGoogleCommonUtilConcurrentClosingFuture_Combiner5 *)whenAllSucceedWithComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future1
                                                                        withComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future2
                                                                        withComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future3
                                                                        withComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future4
                                                                        withComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future5;

/*!
 @brief Starts specifying how to combine <code>ClosingFuture</code>s into a single pipeline, assuming they
  all succeed.If any fail, the resulting pipeline will fail.
 @throw IllegalStateExceptionif a <code>ClosingFuture</code> has already been derived from any of
      the arguments, or if any has already been finished
 */
+ (ComGoogleCommonUtilConcurrentClosingFuture_Combiner *)whenAllSucceedWithComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future1
                                                                       withComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future2
                                                                       withComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future3
                                                                       withComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future4
                                                                       withComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future5
                                                                       withComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)future6
                                                                  withComGoogleCommonUtilConcurrentClosingFutureArray:(IOSObjectArray * __nonnull)moreFutures;

/*!
 @brief Starts specifying how to combine <code>ClosingFuture</code>s into a single pipeline, assuming they
  all succeed.If any fail, the resulting pipeline will fail.
 @throw IllegalStateExceptionif a <code>ClosingFuture</code> has already been derived from any of
      the <code>futures</code>, or if any has already been finished
 */
+ (ComGoogleCommonUtilConcurrentClosingFuture_Combiner *)whenAllSucceedWithJavaLangIterable:(id<JavaLangIterable> __nonnull)futures;

/*!
 @brief Returns an <code>AsyncClosingFunction</code> that applies an <code>AsyncFunction</code> to an input,
  ignoring the DeferredCloser and returning a <code>ClosingFuture</code> derived from the returned 
 <code>ListenableFuture</code>.
 <p>Use this method to pass a transformation to <code>transformAsync(AsyncClosingFunction,
 Executor)</code>
  or to <code>catchingAsync(Class, AsyncClosingFunction, Executor)</code> as long as it
  meets these conditions: 
 <ul>
    <li>It does not need to capture any <code>Closeable</code> objects by calling <code>DeferredCloser.eventuallyClose(Closeable, Executor)</code>
 .
    <li>It returns a <code>ListenableFuture</code>.
  </ul>
  
 <p>Example usage: 
 @code
 // Result.getRowsFuture() returns a ListenableFuture.
  ClosingFuture<List<Row>> rowsFuture =
      queryFuture.transformAsync(withoutCloser(Result::getRowsFuture), executor); 
 
@endcode
 @param function transforms the value of a <code>ClosingFuture</code>  step to a <code>ListenableFuture</code>
   with the value of a derived step
 */
+ (id<ComGoogleCommonUtilConcurrentClosingFuture_AsyncClosingFunction>)withoutCloserWithComGoogleCommonUtilConcurrentAsyncFunction:(id<ComGoogleCommonUtilConcurrentAsyncFunction> __nonnull)function;

#pragma mark Protected

- (void)java_finalize;

#pragma mark Package-Private

/*!
 @brief Returns an object that can be used to wait until this objects' deferred closeables have all had 
 <code>Runnable</code>s that close them submitted to each one's closing <code>Executor</code>.
 */
- (JavaUtilConcurrentCountDownLatch *)whenClosedCountDown;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture)

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentClosingFuture *ComGoogleCommonUtilConcurrentClosingFuture_submitWithComGoogleCommonUtilConcurrentClosingFuture_ClosingCallable_withJavaUtilConcurrentExecutor_(id<ComGoogleCommonUtilConcurrentClosingFuture_ClosingCallable> callable, id<JavaUtilConcurrentExecutor> executor);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentClosingFuture *ComGoogleCommonUtilConcurrentClosingFuture_fromWithComGoogleCommonUtilConcurrentListenableFuture_(id<ComGoogleCommonUtilConcurrentListenableFuture> future);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentClosingFuture *ComGoogleCommonUtilConcurrentClosingFuture_eventuallyClosingWithComGoogleCommonUtilConcurrentListenableFuture_withJavaUtilConcurrentExecutor_(id<ComGoogleCommonUtilConcurrentListenableFuture> future, id<JavaUtilConcurrentExecutor> closingExecutor);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentClosingFuture_Combiner *ComGoogleCommonUtilConcurrentClosingFuture_whenAllCompleteWithJavaLangIterable_(id<JavaLangIterable> futures);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentClosingFuture_Combiner *ComGoogleCommonUtilConcurrentClosingFuture_whenAllCompleteWithComGoogleCommonUtilConcurrentClosingFuture_withComGoogleCommonUtilConcurrentClosingFutureArray_(ComGoogleCommonUtilConcurrentClosingFuture *future1, IOSObjectArray *moreFutures);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentClosingFuture_Combiner *ComGoogleCommonUtilConcurrentClosingFuture_whenAllSucceedWithJavaLangIterable_(id<JavaLangIterable> futures);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentClosingFuture_Combiner2 *ComGoogleCommonUtilConcurrentClosingFuture_whenAllSucceedWithComGoogleCommonUtilConcurrentClosingFuture_withComGoogleCommonUtilConcurrentClosingFuture_(ComGoogleCommonUtilConcurrentClosingFuture *future1, ComGoogleCommonUtilConcurrentClosingFuture *future2);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentClosingFuture_Combiner3 *ComGoogleCommonUtilConcurrentClosingFuture_whenAllSucceedWithComGoogleCommonUtilConcurrentClosingFuture_withComGoogleCommonUtilConcurrentClosingFuture_withComGoogleCommonUtilConcurrentClosingFuture_(ComGoogleCommonUtilConcurrentClosingFuture *future1, ComGoogleCommonUtilConcurrentClosingFuture *future2, ComGoogleCommonUtilConcurrentClosingFuture *future3);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentClosingFuture_Combiner4 *ComGoogleCommonUtilConcurrentClosingFuture_whenAllSucceedWithComGoogleCommonUtilConcurrentClosingFuture_withComGoogleCommonUtilConcurrentClosingFuture_withComGoogleCommonUtilConcurrentClosingFuture_withComGoogleCommonUtilConcurrentClosingFuture_(ComGoogleCommonUtilConcurrentClosingFuture *future1, ComGoogleCommonUtilConcurrentClosingFuture *future2, ComGoogleCommonUtilConcurrentClosingFuture *future3, ComGoogleCommonUtilConcurrentClosingFuture *future4);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentClosingFuture_Combiner5 *ComGoogleCommonUtilConcurrentClosingFuture_whenAllSucceedWithComGoogleCommonUtilConcurrentClosingFuture_withComGoogleCommonUtilConcurrentClosingFuture_withComGoogleCommonUtilConcurrentClosingFuture_withComGoogleCommonUtilConcurrentClosingFuture_withComGoogleCommonUtilConcurrentClosingFuture_(ComGoogleCommonUtilConcurrentClosingFuture *future1, ComGoogleCommonUtilConcurrentClosingFuture *future2, ComGoogleCommonUtilConcurrentClosingFuture *future3, ComGoogleCommonUtilConcurrentClosingFuture *future4, ComGoogleCommonUtilConcurrentClosingFuture *future5);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentClosingFuture_Combiner *ComGoogleCommonUtilConcurrentClosingFuture_whenAllSucceedWithComGoogleCommonUtilConcurrentClosingFuture_withComGoogleCommonUtilConcurrentClosingFuture_withComGoogleCommonUtilConcurrentClosingFuture_withComGoogleCommonUtilConcurrentClosingFuture_withComGoogleCommonUtilConcurrentClosingFuture_withComGoogleCommonUtilConcurrentClosingFuture_withComGoogleCommonUtilConcurrentClosingFutureArray_(ComGoogleCommonUtilConcurrentClosingFuture *future1, ComGoogleCommonUtilConcurrentClosingFuture *future2, ComGoogleCommonUtilConcurrentClosingFuture *future3, ComGoogleCommonUtilConcurrentClosingFuture *future4, ComGoogleCommonUtilConcurrentClosingFuture *future5, ComGoogleCommonUtilConcurrentClosingFuture *future6, IOSObjectArray *moreFutures);

FOUNDATION_EXPORT id<ComGoogleCommonUtilConcurrentClosingFuture_AsyncClosingFunction> ComGoogleCommonUtilConcurrentClosingFuture_withoutCloserWithComGoogleCommonUtilConcurrentAsyncFunction_(id<ComGoogleCommonUtilConcurrentAsyncFunction> function);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser))
#define ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser_

@class ComGoogleCommonUtilConcurrentClosingFuture_CloseableList;
@protocol JavaIoCloseable;
@protocol JavaUtilConcurrentExecutor;

/*!
 @brief An object that can capture objects to be closed later, when a <code>ClosingFuture</code> pipeline is
  done.
 */
@interface ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser : NSObject

#pragma mark Public

/*!
 @brief Captures an object to be closed when a <code>ClosingFuture</code> pipeline is done.
 <p>For users of the <code>-jre</code> flavor of Guava, the object can be any <code>AutoCloseable</code>
 . For users of the <code>-android</code> flavor, the object must be a <code>Closeable</code>
 . (For more about the flavors, see <a href="https://github.com/google/guava#adding-guava-to-your-build">
 Adding Guava to your
  build</a>.)
  
 <p>Be careful when targeting an older SDK than you are building against (most commonly when
  building for Android): Ensure that any object you pass implements the interface not just in
  your current SDK version but also at the oldest version you support. For example, <a href="https://developer.android.com/sdk/api_diff/16/">
 API Level 16</a> is the first version
  in which <code>Cursor</code> is <code>Closeable</code>. To support older versions, pass a wrapper 
 <code>Closeable</code> with a method reference like <code>cursor::close</code>.
  
 <p>Note that this method is still binary-compatible between flavors because the erasure of
  its parameter type is <code>Object</code>, not <code>AutoCloseable</code> or <code>Closeable</code>.
 @param closeable the object to be closed (see notes above)
 @param closingExecutor the object will be closed on this executor
 @return the first argument
 */
- (id<JavaIoCloseable> __nullable)eventuallyCloseWithId:(id<JavaIoCloseable> __nullable)closeable
                         withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)closingExecutor;

#pragma mark Package-Private

- (instancetype __nonnull)initWithComGoogleCommonUtilConcurrentClosingFuture_CloseableList:(ComGoogleCommonUtilConcurrentClosingFuture_CloseableList * __nonnull)list;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser)

FOUNDATION_EXPORT void ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser_initWithComGoogleCommonUtilConcurrentClosingFuture_CloseableList_(ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser *self, ComGoogleCommonUtilConcurrentClosingFuture_CloseableList *list);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser *new_ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser_initWithComGoogleCommonUtilConcurrentClosingFuture_CloseableList_(ComGoogleCommonUtilConcurrentClosingFuture_CloseableList *list) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser *create_ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser_initWithComGoogleCommonUtilConcurrentClosingFuture_CloseableList_(ComGoogleCommonUtilConcurrentClosingFuture_CloseableList *list);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_ClosingCallable_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_ClosingCallable))
#define ComGoogleCommonUtilConcurrentClosingFuture_ClosingCallable_

@class ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser;

/*!
 @brief An operation that computes a result.
 */
@protocol ComGoogleCommonUtilConcurrentClosingFuture_ClosingCallable < JavaObject >

/*!
 @brief Computes a result, or throws an exception if unable to do so.
 <p>Any objects that are passed to <code>closer.eventuallyClose()</code>
  will be closed when the <code>ClosingFuture</code> pipeline is done (but
  not before this method completes), even if this method throws or the pipeline is cancelled.
 */
- (id __nullable)callWithComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser:(ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser * __nonnull)closer;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_ClosingCallable)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_ClosingCallable)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_ClosingFunction_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_ClosingFunction))
#define ComGoogleCommonUtilConcurrentClosingFuture_ClosingFunction_

@class ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser;

/*!
 @brief A function from an input to a result.
 */
@protocol ComGoogleCommonUtilConcurrentClosingFuture_ClosingFunction < JavaObject >

/*!
 @brief Applies this function to an input, or throws an exception if unable to do so.
 <p>Any objects that are passed to <code>closer.eventuallyClose()</code>
  will be closed when the <code>ClosingFuture</code> pipeline is done (but
  not before this method completes), even if this method throws or the pipeline is cancelled.
 */
- (id __nullable)applyWithComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser:(ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser * __nonnull)closer
                                                                             withId:(id __nullable)input;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_ClosingFunction)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_ClosingFunction)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_AsyncClosingFunction_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_AsyncClosingFunction))
#define ComGoogleCommonUtilConcurrentClosingFuture_AsyncClosingFunction_

@class ComGoogleCommonUtilConcurrentClosingFuture;
@class ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser;

/*!
 @brief A function from an input to a <code>ClosingFuture</code> of a result.
 */
@protocol ComGoogleCommonUtilConcurrentClosingFuture_AsyncClosingFunction < JavaObject >

/*!
 @brief Applies this function to an input, or throws an exception if unable to do so.
 <p>Any objects that are passed to <code>closer.eventuallyClose()</code>
  will be closed when the <code>ClosingFuture</code> pipeline is done (but
  not before this method completes), even if this method throws or the pipeline is cancelled.
 */
- (ComGoogleCommonUtilConcurrentClosingFuture *)applyWithComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser:(ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser * __nonnull)closer
                                                                                                            withId:(id __nullable)input;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_AsyncClosingFunction)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_AsyncClosingFunction)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloser_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloser))
#define ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloser_

@class ComGoogleCommonUtilConcurrentClosingFuture;

/*!
 @brief An object that holds the final result of an asynchronous <code>ClosingFuture</code> operation and
  allows the user to close all the closeable objects that were captured during it for later
  closing.
 <p>The asynchronous operation will have completed before this object is created.
 - seealso: ClosingFuture#finishToValueAndCloser(ValueAndCloserConsumer, Executor)
 */
@interface ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloser : NSObject

#pragma mark Public

/*!
 @brief Starts closing all closeable objects captured during the <code>ClosingFuture</code>'s asynchronous
  operation on the <code>Executor</code>s specified by calls to <code>DeferredCloser.eventuallyClose(Closeable, Executor)</code>
 .
 <p>If any such calls specified <code>MoreExecutors.directExecutor()</code>, those objects will be
  closed synchronously. 
 <p>Idempotent: objects will be closed at most once.
 */
- (void)closeAsync;

/*!
 @brief Returns the final value of the associated <code>ClosingFuture</code>, or throws an exception as 
 <code>Future.get()</code> would.
 <p>Because the asynchronous operation has already completed, this method is synchronous and
  returns immediately.
 @throw CancellationExceptionif the computation was cancelled
 @throw ExecutionExceptionif the computation threw an exception
 */
- (id __nullable)get;

#pragma mark Package-Private

- (instancetype __nonnull)initWithComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)closingFuture;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloser)

FOUNDATION_EXPORT void ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloser_initWithComGoogleCommonUtilConcurrentClosingFuture_(ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloser *self, ComGoogleCommonUtilConcurrentClosingFuture *closingFuture);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloser *new_ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloser_initWithComGoogleCommonUtilConcurrentClosingFuture_(ComGoogleCommonUtilConcurrentClosingFuture *closingFuture) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloser *create_ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloser_initWithComGoogleCommonUtilConcurrentClosingFuture_(ComGoogleCommonUtilConcurrentClosingFuture *closingFuture);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloser)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloserConsumer_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloserConsumer))
#define ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloserConsumer_

@class ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloser;

/*!
 @brief Represents an operation that accepts a <code>ValueAndCloser</code> for the last step in a <code>ClosingFuture</code>
  pipeline.
 - seealso: ClosingFuture#finishToValueAndCloser(ValueAndCloserConsumer, Executor)
 */
@protocol ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloserConsumer < JavaObject >

/*!
 @brief Accepts a <code>ValueAndCloser</code> for the last step in a <code>ClosingFuture</code> pipeline.
 */
- (void)acceptWithComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloser:(ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloser * __nonnull)valueAndCloser;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloserConsumer)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_ValueAndCloserConsumer)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_Peeker_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Peeker))
#define ComGoogleCommonUtilConcurrentClosingFuture_Peeker_

@class ComGoogleCommonUtilConcurrentClosingFuture;

/*!
 @brief An object that can return the value of the <code>ClosingFuture</code>s that are passed to <code>whenAllComplete(Iterable)</code>
  or <code>whenAllSucceed(Iterable)</code>.
 <p>Only for use by a <code>CombiningCallable</code> or <code>AsyncCombiningCallable</code> object.
 */
@interface ComGoogleCommonUtilConcurrentClosingFuture_Peeker : NSObject

#pragma mark Public

/*!
 @brief Returns the value of <code>closingFuture</code>.
 @throw ExecutionExceptionif <code>closingFuture</code> is a failed step
 @throw CancellationExceptionif the <code>closingFuture</code>'s future was cancelled
 @throw IllegalArgumentExceptionif <code>closingFuture</code> is not one of the futures passed to
      <code>whenAllComplete(Iterable)</code> or <code>whenAllComplete(Iterable)</code>
 @throw IllegalStateExceptionif called outside of a call to <code>CombiningCallable.call(DeferredCloser, Peeker)</code>
  or <code>AsyncCombiningCallable.call(DeferredCloser, Peeker)</code>
 */
- (id __nullable)getDoneWithComGoogleCommonUtilConcurrentClosingFuture:(ComGoogleCommonUtilConcurrentClosingFuture * __nonnull)closingFuture;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_Peeker)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_Peeker)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_Combiner_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner))
#define ComGoogleCommonUtilConcurrentClosingFuture_Combiner_

@class ComGoogleCommonCollectImmutableList;
@class ComGoogleCommonUtilConcurrentClosingFuture;
@protocol ComGoogleCommonUtilConcurrentClosingFuture_Combiner_AsyncCombiningCallable;
@protocol ComGoogleCommonUtilConcurrentClosingFuture_Combiner_CombiningCallable;
@protocol JavaUtilConcurrentExecutor;

/*!
 @brief A builder of a <code>ClosingFuture</code> step that is derived from more than one input step.
 <p>See <code>whenAllComplete(Iterable)</code> and <code>whenAllSucceed(Iterable)</code> for how to
  instantiate this class. 
 <p>Example:
  
 @code
 final ClosingFuture<BufferedReader> file1ReaderFuture = ...;
  final ClosingFuture<BufferedReader> file2ReaderFuture = ...;
  ListenableFuture<Integer> numberOfDifferentLines =
        ClosingFuture.whenAllSucceed(file1ReaderFuture, file2ReaderFuture)
            .call(
                (closer, peeker) -> {
                  BufferedReader file1Reader = peeker.getDone(file1ReaderFuture);
                  BufferedReader file2Reader = peeker.getDone(file2ReaderFuture);
                  return countDifferentLines(file1Reader, file2Reader);
                },
                executor)
            .closing(executor); 
 
@endcode
 */
@interface ComGoogleCommonUtilConcurrentClosingFuture_Combiner : NSObject {
 @public
  ComGoogleCommonCollectImmutableList *inputs_;
}

#pragma mark Public

/*!
 @brief Returns a new <code>ClosingFuture</code> pipeline step derived from the inputs by applying a
  combining function to their values.The function can use a <code>DeferredCloser</code> to capture
  objects to be closed when the pipeline is done.
 <p>If this combiner was returned by a <code>whenAllSucceed</code> method and any of the inputs
  fail, so will the returned step. 
 <p>If the combiningCallable throws a <code>CancellationException</code>, the pipeline will be
  cancelled. 
 <p>If the combiningCallable throws an <code>ExecutionException</code>, the cause of the thrown 
 <code>ExecutionException</code> will be extracted and used as the failure of the derived step.
 */
- (ComGoogleCommonUtilConcurrentClosingFuture *)callWithComGoogleCommonUtilConcurrentClosingFuture_Combiner_CombiningCallable:(id<ComGoogleCommonUtilConcurrentClosingFuture_Combiner_CombiningCallable> __nonnull)combiningCallable
                                                                                               withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

/*!
 @brief Returns a new <code>ClosingFuture</code> pipeline step derived from the inputs by applying a 
 <code>ClosingFuture</code>-returning function to their values.The function can use a <code>DeferredCloser</code>
  to capture objects to be closed when the pipeline is done (other than those
  captured by the returned <code>ClosingFuture</code>).
 <p>If this combiner was returned by a <code>whenAllSucceed</code> method and any of the inputs
  fail, so will the returned step. 
 <p>If the combiningCallable throws a <code>CancellationException</code>, the pipeline will be
  cancelled. 
 <p>If the combiningCallable throws an <code>ExecutionException</code>, the cause of the thrown 
 <code>ExecutionException</code> will be extracted and used as the failure of the derived step. 
 <p>If the combiningCallable throws any other exception, it will be used as the failure of the
  derived step. 
 <p>If an exception is thrown after the combiningCallable creates a <code>ClosingFuture</code>,
  then none of the closeable objects in that <code>ClosingFuture</code> will be closed. 
 <p>Usage guidelines for this method: 
 <ul>
    <li>Use this method only when calling an API that returns a <code>ListenableFuture</code> or a
        <code>ClosingFuture</code>. If possible, prefer calling <code>call(CombiningCallable,
       Executor)</code>
  instead, with a function that returns the next value directly.
    <li>Call <code>closer.eventuallyClose()</code>
  for every closeable object this step creates in order to
        capture it for later closing.   
 <li>Return a <code>ClosingFuture</code>. To turn a <code>ListenableFuture</code> into a <code>ClosingFuture</code>
  call <code>from(ListenableFuture)</code>.
  </ul>
  
 <p>The same warnings about doing heavyweight operations within <code>ClosingFuture.transformAsync(AsyncClosingFunction, Executor)</code>
  apply here.
 */
- (ComGoogleCommonUtilConcurrentClosingFuture *)callAsyncWithComGoogleCommonUtilConcurrentClosingFuture_Combiner_AsyncCombiningCallable:(id<ComGoogleCommonUtilConcurrentClosingFuture_Combiner_AsyncCombiningCallable> __nonnull)combiningCallable
                                                                                                         withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_Combiner)

J2OBJC_FIELD_SETTER(ComGoogleCommonUtilConcurrentClosingFuture_Combiner, inputs_, ComGoogleCommonCollectImmutableList *)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_Combiner)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_Combiner_CombiningCallable_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner_CombiningCallable))
#define ComGoogleCommonUtilConcurrentClosingFuture_Combiner_CombiningCallable_

@class ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser;
@class ComGoogleCommonUtilConcurrentClosingFuture_Peeker;

/*!
 @brief An operation that returns a result and may throw an exception.
 */
@protocol ComGoogleCommonUtilConcurrentClosingFuture_Combiner_CombiningCallable < JavaObject >

/*!
 @brief Computes a result, or throws an exception if unable to do so.
 <p>Any objects that are passed to <code>closer.eventuallyClose()</code>
  will be closed when the <code>ClosingFuture</code> pipeline
  is done (but not before this method completes), even if this method throws or the pipeline
  is cancelled.
 @param peeker used to get the value of any of the input futures
 */
- (id __nullable)callWithComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser:(ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser * __nonnull)closer
                             withComGoogleCommonUtilConcurrentClosingFuture_Peeker:(ComGoogleCommonUtilConcurrentClosingFuture_Peeker * __nonnull)peeker;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_Combiner_CombiningCallable)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_Combiner_CombiningCallable)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_Combiner_AsyncCombiningCallable_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner_AsyncCombiningCallable))
#define ComGoogleCommonUtilConcurrentClosingFuture_Combiner_AsyncCombiningCallable_

@class ComGoogleCommonUtilConcurrentClosingFuture;
@class ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser;
@class ComGoogleCommonUtilConcurrentClosingFuture_Peeker;

/*!
 @brief An operation that returns a <code>ClosingFuture</code> result and may throw an exception.
 */
@protocol ComGoogleCommonUtilConcurrentClosingFuture_Combiner_AsyncCombiningCallable < JavaObject >

/*!
 @brief Computes a <code>ClosingFuture</code> result, or throws an exception if unable to do so.
 <p>Any objects that are passed to <code>closer.eventuallyClose()</code>
  will be closed when the <code>ClosingFuture</code> pipeline
  is done (but not before this method completes), even if this method throws or the pipeline
  is cancelled.
 @param peeker used to get the value of any of the input futures
 */
- (ComGoogleCommonUtilConcurrentClosingFuture *)callWithComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser:(ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser * __nonnull)closer
                                                            withComGoogleCommonUtilConcurrentClosingFuture_Peeker:(ComGoogleCommonUtilConcurrentClosingFuture_Peeker * __nonnull)peeker;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_Combiner_AsyncCombiningCallable)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_Combiner_AsyncCombiningCallable)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_Combiner2_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner2))
#define ComGoogleCommonUtilConcurrentClosingFuture_Combiner2_

@class ComGoogleCommonUtilConcurrentClosingFuture;
@protocol ComGoogleCommonUtilConcurrentClosingFuture_Combiner2_AsyncClosingFunction2;
@protocol ComGoogleCommonUtilConcurrentClosingFuture_Combiner2_ClosingFunction2;
@protocol JavaUtilConcurrentExecutor;

/*!
 @brief A generic <code>Combiner</code> that lets you use a lambda or method reference to combine two <code>ClosingFuture</code>
 s.Use <code>whenAllSucceed(ClosingFuture, ClosingFuture)</code> to start this
  combination.
 */
@interface ComGoogleCommonUtilConcurrentClosingFuture_Combiner2 : ComGoogleCommonUtilConcurrentClosingFuture_Combiner

#pragma mark Public

/*!
 @brief Returns a new <code>ClosingFuture</code> pipeline step derived from the inputs by applying a
  combining function to their values.The function can use a <code>DeferredCloser</code> to capture
  objects to be closed when the pipeline is done.
 <p>If this combiner was returned by <code>whenAllSucceed(ClosingFuture, ClosingFuture)</code> and
  any of the inputs fail, so will the returned step. 
 <p>If the function throws a <code>CancellationException</code>, the pipeline will be cancelled. 
 <p>If the function throws an <code>ExecutionException</code>, the cause of the thrown <code>ExecutionException</code>
  will be extracted and used as the failure of the derived step.
 */
- (ComGoogleCommonUtilConcurrentClosingFuture *)callWithComGoogleCommonUtilConcurrentClosingFuture_Combiner2_ClosingFunction2:(id<ComGoogleCommonUtilConcurrentClosingFuture_Combiner2_ClosingFunction2> __nonnull)function
                                                                                               withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

/*!
 @brief Returns a new <code>ClosingFuture</code> pipeline step derived from the inputs by applying a 
 <code>ClosingFuture</code>-returning function to their values.The function can use a <code>DeferredCloser</code>
  to capture objects to be closed when the pipeline is done (other than those
  captured by the returned <code>ClosingFuture</code>).
 <p>If this combiner was returned by <code>whenAllSucceed(ClosingFuture, ClosingFuture)</code> and
  any of the inputs fail, so will the returned step. 
 <p>If the function throws a <code>CancellationException</code>, the pipeline will be cancelled. 
 <p>If the function throws an <code>ExecutionException</code>, the cause of the thrown <code>ExecutionException</code>
  will be extracted and used as the failure of the derived step. 
 <p>If the function throws any other exception, it will be used as the failure of the derived
  step. 
 <p>If an exception is thrown after the function creates a <code>ClosingFuture</code>, then none of
  the closeable objects in that <code>ClosingFuture</code> will be closed. 
 <p>Usage guidelines for this method: 
 <ul>
    <li>Use this method only when calling an API that returns a <code>ListenableFuture</code> or a
        <code>ClosingFuture</code>. If possible, prefer calling <code>call(CombiningCallable,
       Executor)</code>
  instead, with a function that returns the next value directly.
    <li>Call <code>closer.eventuallyClose()</code>
  for every closeable object this step creates in order to
        capture it for later closing.   
 <li>Return a <code>ClosingFuture</code>. To turn a <code>ListenableFuture</code> into a <code>ClosingFuture</code>
  call <code>from(ListenableFuture)</code>.
  </ul>
  
 <p>The same warnings about doing heavyweight operations within <code>ClosingFuture.transformAsync(AsyncClosingFunction, Executor)</code>
  apply here.
 */
- (ComGoogleCommonUtilConcurrentClosingFuture *)callAsyncWithComGoogleCommonUtilConcurrentClosingFuture_Combiner2_AsyncClosingFunction2:(id<ComGoogleCommonUtilConcurrentClosingFuture_Combiner2_AsyncClosingFunction2> __nonnull)function
                                                                                                         withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_Combiner2)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_Combiner2)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_Combiner2_ClosingFunction2_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner2_ClosingFunction2))
#define ComGoogleCommonUtilConcurrentClosingFuture_Combiner2_ClosingFunction2_

@class ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser;

/*!
 @brief A function that returns a value when applied to the values of the two futures passed to 
 <code>whenAllSucceed(ClosingFuture, ClosingFuture)</code>.
 */
@protocol ComGoogleCommonUtilConcurrentClosingFuture_Combiner2_ClosingFunction2 < JavaObject >

/*!
 @brief Applies this function to two inputs, or throws an exception if unable to do so.
 <p>Any objects that are passed to <code>closer.eventuallyClose()</code>
  will be closed when the <code>ClosingFuture</code> pipeline
  is done (but not before this method completes), even if this method throws or the pipeline
  is cancelled.
 */
- (id __nullable)applyWithComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser:(ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser * __nonnull)closer
                                                                             withId:(id __nullable)value1
                                                                             withId:(id __nullable)value2;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_Combiner2_ClosingFunction2)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_Combiner2_ClosingFunction2)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_Combiner2_AsyncClosingFunction2_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner2_AsyncClosingFunction2))
#define ComGoogleCommonUtilConcurrentClosingFuture_Combiner2_AsyncClosingFunction2_

@class ComGoogleCommonUtilConcurrentClosingFuture;
@class ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser;

/*!
 @brief A function that returns a <code>ClosingFuture</code> when applied to the values of the two futures
  passed to <code>whenAllSucceed(ClosingFuture, ClosingFuture)</code>.
 */
@protocol ComGoogleCommonUtilConcurrentClosingFuture_Combiner2_AsyncClosingFunction2 < JavaObject >

/*!
 @brief Applies this function to two inputs, or throws an exception if unable to do so.
 <p>Any objects that are passed to <code>closer.eventuallyClose()</code>
  will be closed when the <code>ClosingFuture</code> pipeline
  is done (but not before this method completes), even if this method throws or the pipeline
  is cancelled.
 */
- (ComGoogleCommonUtilConcurrentClosingFuture *)applyWithComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser:(ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser * __nonnull)closer
                                                                                                            withId:(id __nullable)value1
                                                                                                            withId:(id __nullable)value2;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_Combiner2_AsyncClosingFunction2)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_Combiner2_AsyncClosingFunction2)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_Combiner3_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner3))
#define ComGoogleCommonUtilConcurrentClosingFuture_Combiner3_

@class ComGoogleCommonUtilConcurrentClosingFuture;
@protocol ComGoogleCommonUtilConcurrentClosingFuture_Combiner3_AsyncClosingFunction3;
@protocol ComGoogleCommonUtilConcurrentClosingFuture_Combiner3_ClosingFunction3;
@protocol JavaUtilConcurrentExecutor;

/*!
 @brief A generic <code>Combiner</code> that lets you use a lambda or method reference to combine three 
 <code>ClosingFuture</code>s.Use <code>whenAllSucceed(ClosingFuture, ClosingFuture,
 ClosingFuture)</code>
  to start this combination.
 */
@interface ComGoogleCommonUtilConcurrentClosingFuture_Combiner3 : ComGoogleCommonUtilConcurrentClosingFuture_Combiner

#pragma mark Public

/*!
 @brief Returns a new <code>ClosingFuture</code> pipeline step derived from the inputs by applying a
  combining function to their values.The function can use a <code>DeferredCloser</code> to capture
  objects to be closed when the pipeline is done.
 <p>If this combiner was returned by <code>whenAllSucceed(ClosingFuture, ClosingFuture,
 ClosingFuture)</code>
  and any of the inputs fail, so will the returned step. 
 <p>If the function throws a <code>CancellationException</code>, the pipeline will be cancelled. 
 <p>If the function throws an <code>ExecutionException</code>, the cause of the thrown <code>ExecutionException</code>
  will be extracted and used as the failure of the derived step.
 */
- (ComGoogleCommonUtilConcurrentClosingFuture *)callWithComGoogleCommonUtilConcurrentClosingFuture_Combiner3_ClosingFunction3:(id<ComGoogleCommonUtilConcurrentClosingFuture_Combiner3_ClosingFunction3> __nonnull)function
                                                                                               withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

/*!
 @brief Returns a new <code>ClosingFuture</code> pipeline step derived from the inputs by applying a 
 <code>ClosingFuture</code>-returning function to their values.The function can use a <code>DeferredCloser</code>
  to capture objects to be closed when the pipeline is done (other than those
  captured by the returned <code>ClosingFuture</code>).
 <p>If this combiner was returned by <code>whenAllSucceed(ClosingFuture, ClosingFuture,
 ClosingFuture)</code>
  and any of the inputs fail, so will the returned step. 
 <p>If the function throws a <code>CancellationException</code>, the pipeline will be cancelled. 
 <p>If the function throws an <code>ExecutionException</code>, the cause of the thrown <code>ExecutionException</code>
  will be extracted and used as the failure of the derived step. 
 <p>If the function throws any other exception, it will be used as the failure of the derived
  step. 
 <p>If an exception is thrown after the function creates a <code>ClosingFuture</code>, then none of
  the closeable objects in that <code>ClosingFuture</code> will be closed. 
 <p>Usage guidelines for this method: 
 <ul>
    <li>Use this method only when calling an API that returns a <code>ListenableFuture</code> or a
        <code>ClosingFuture</code>. If possible, prefer calling <code>call(CombiningCallable,
       Executor)</code>
  instead, with a function that returns the next value directly.
    <li>Call <code>closer.eventuallyClose()</code>
  for every closeable object this step creates in order to
        capture it for later closing.   
 <li>Return a <code>ClosingFuture</code>. To turn a <code>ListenableFuture</code> into a <code>ClosingFuture</code>
  call <code>from(ListenableFuture)</code>.
  </ul>
  
 <p>The same warnings about doing heavyweight operations within <code>ClosingFuture.transformAsync(AsyncClosingFunction, Executor)</code>
  apply here.
 */
- (ComGoogleCommonUtilConcurrentClosingFuture *)callAsyncWithComGoogleCommonUtilConcurrentClosingFuture_Combiner3_AsyncClosingFunction3:(id<ComGoogleCommonUtilConcurrentClosingFuture_Combiner3_AsyncClosingFunction3> __nonnull)function
                                                                                                         withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_Combiner3)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_Combiner3)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_Combiner3_ClosingFunction3_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner3_ClosingFunction3))
#define ComGoogleCommonUtilConcurrentClosingFuture_Combiner3_ClosingFunction3_

@class ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser;

/*!
 @brief A function that returns a value when applied to the values of the three futures passed to 
 <code>whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture)</code>.
 */
@protocol ComGoogleCommonUtilConcurrentClosingFuture_Combiner3_ClosingFunction3 < JavaObject >

/*!
 @brief Applies this function to three inputs, or throws an exception if unable to do so.
 <p>Any objects that are passed to <code>closer.eventuallyClose()</code>
  will be closed when the <code>ClosingFuture</code> pipeline
  is done (but not before this method completes), even if this method throws or the pipeline
  is cancelled.
 */
- (id __nullable)applyWithComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser:(ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser * __nonnull)closer
                                                                             withId:(id __nullable)value1
                                                                             withId:(id __nullable)value2
                                                                             withId:(id __nullable)v3;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_Combiner3_ClosingFunction3)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_Combiner3_ClosingFunction3)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_Combiner3_AsyncClosingFunction3_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner3_AsyncClosingFunction3))
#define ComGoogleCommonUtilConcurrentClosingFuture_Combiner3_AsyncClosingFunction3_

@class ComGoogleCommonUtilConcurrentClosingFuture;
@class ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser;

/*!
 @brief A function that returns a <code>ClosingFuture</code> when applied to the values of the three
  futures passed to <code>whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture)</code>.
 */
@protocol ComGoogleCommonUtilConcurrentClosingFuture_Combiner3_AsyncClosingFunction3 < JavaObject >

/*!
 @brief Applies this function to three inputs, or throws an exception if unable to do so.
 <p>Any objects that are passed to <code>closer.eventuallyClose()</code>
  will be closed when the <code>ClosingFuture</code> pipeline
  is done (but not before this method completes), even if this method throws or the pipeline
  is cancelled.
 */
- (ComGoogleCommonUtilConcurrentClosingFuture *)applyWithComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser:(ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser * __nonnull)closer
                                                                                                            withId:(id __nullable)value1
                                                                                                            withId:(id __nullable)value2
                                                                                                            withId:(id __nullable)value3;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_Combiner3_AsyncClosingFunction3)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_Combiner3_AsyncClosingFunction3)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_Combiner4_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner4))
#define ComGoogleCommonUtilConcurrentClosingFuture_Combiner4_

@class ComGoogleCommonUtilConcurrentClosingFuture;
@protocol ComGoogleCommonUtilConcurrentClosingFuture_Combiner4_AsyncClosingFunction4;
@protocol ComGoogleCommonUtilConcurrentClosingFuture_Combiner4_ClosingFunction4;
@protocol JavaUtilConcurrentExecutor;

/*!
 @brief A generic <code>Combiner</code> that lets you use a lambda or method reference to combine four 
 <code>ClosingFuture</code>s.Use <code>whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture,
 ClosingFuture)</code>
  to start this combination.
 */
@interface ComGoogleCommonUtilConcurrentClosingFuture_Combiner4 : ComGoogleCommonUtilConcurrentClosingFuture_Combiner

#pragma mark Public

/*!
 @brief Returns a new <code>ClosingFuture</code> pipeline step derived from the inputs by applying a
  combining function to their values.The function can use a <code>DeferredCloser</code> to capture
  objects to be closed when the pipeline is done.
 <p>If this combiner was returned by <code>whenAllSucceed(ClosingFuture, ClosingFuture,
 ClosingFuture, ClosingFuture)</code>
  and any of the inputs fail, so will the returned step. 
 <p>If the function throws a <code>CancellationException</code>, the pipeline will be cancelled. 
 <p>If the function throws an <code>ExecutionException</code>, the cause of the thrown <code>ExecutionException</code>
  will be extracted and used as the failure of the derived step.
 */
- (ComGoogleCommonUtilConcurrentClosingFuture *)callWithComGoogleCommonUtilConcurrentClosingFuture_Combiner4_ClosingFunction4:(id<ComGoogleCommonUtilConcurrentClosingFuture_Combiner4_ClosingFunction4> __nonnull)function
                                                                                               withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

/*!
 @brief Returns a new <code>ClosingFuture</code> pipeline step derived from the inputs by applying a 
 <code>ClosingFuture</code>-returning function to their values.The function can use a <code>DeferredCloser</code>
  to capture objects to be closed when the pipeline is done (other than those
  captured by the returned <code>ClosingFuture</code>).
 <p>If this combiner was returned by <code>whenAllSucceed(ClosingFuture, ClosingFuture,
 ClosingFuture, ClosingFuture)</code>
  and any of the inputs fail, so will the returned step. 
 <p>If the function throws a <code>CancellationException</code>, the pipeline will be cancelled. 
 <p>If the function throws an <code>ExecutionException</code>, the cause of the thrown <code>ExecutionException</code>
  will be extracted and used as the failure of the derived step. 
 <p>If the function throws any other exception, it will be used as the failure of the derived
  step. 
 <p>If an exception is thrown after the function creates a <code>ClosingFuture</code>, then none of
  the closeable objects in that <code>ClosingFuture</code> will be closed. 
 <p>Usage guidelines for this method: 
 <ul>
    <li>Use this method only when calling an API that returns a <code>ListenableFuture</code> or a
        <code>ClosingFuture</code>. If possible, prefer calling <code>call(CombiningCallable,
       Executor)</code>
  instead, with a function that returns the next value directly.
    <li>Call <code>closer.eventuallyClose()</code>
  for every closeable object this step creates in order to
        capture it for later closing.   
 <li>Return a <code>ClosingFuture</code>. To turn a <code>ListenableFuture</code> into a <code>ClosingFuture</code>
  call <code>from(ListenableFuture)</code>.
  </ul>
  
 <p>The same warnings about doing heavyweight operations within <code>ClosingFuture.transformAsync(AsyncClosingFunction, Executor)</code>
  apply here.
 */
- (ComGoogleCommonUtilConcurrentClosingFuture *)callAsyncWithComGoogleCommonUtilConcurrentClosingFuture_Combiner4_AsyncClosingFunction4:(id<ComGoogleCommonUtilConcurrentClosingFuture_Combiner4_AsyncClosingFunction4> __nonnull)function
                                                                                                         withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_Combiner4)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_Combiner4)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_Combiner4_ClosingFunction4_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner4_ClosingFunction4))
#define ComGoogleCommonUtilConcurrentClosingFuture_Combiner4_ClosingFunction4_

@class ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser;

/*!
 @brief A function that returns a value when applied to the values of the four futures passed to 
 <code>whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture)</code>.
 */
@protocol ComGoogleCommonUtilConcurrentClosingFuture_Combiner4_ClosingFunction4 < JavaObject >

/*!
 @brief Applies this function to four inputs, or throws an exception if unable to do so.
 <p>Any objects that are passed to <code>closer.eventuallyClose()</code>
  will be closed when the <code>ClosingFuture</code> pipeline
  is done (but not before this method completes), even if this method throws or the pipeline
  is cancelled.
 */
- (id __nullable)applyWithComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser:(ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser * __nonnull)closer
                                                                             withId:(id __nullable)value1
                                                                             withId:(id __nullable)value2
                                                                             withId:(id __nullable)value3
                                                                             withId:(id __nullable)value4;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_Combiner4_ClosingFunction4)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_Combiner4_ClosingFunction4)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_Combiner4_AsyncClosingFunction4_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner4_AsyncClosingFunction4))
#define ComGoogleCommonUtilConcurrentClosingFuture_Combiner4_AsyncClosingFunction4_

@class ComGoogleCommonUtilConcurrentClosingFuture;
@class ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser;

/*!
 @brief A function that returns a <code>ClosingFuture</code> when applied to the values of the four
  futures passed to <code>whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture,
 ClosingFuture)</code>
 .
 */
@protocol ComGoogleCommonUtilConcurrentClosingFuture_Combiner4_AsyncClosingFunction4 < JavaObject >

/*!
 @brief Applies this function to four inputs, or throws an exception if unable to do so.
 <p>Any objects that are passed to <code>closer.eventuallyClose()</code>
  will be closed when the <code>ClosingFuture</code> pipeline
  is done (but not before this method completes), even if this method throws or the pipeline
  is cancelled.
 */
- (ComGoogleCommonUtilConcurrentClosingFuture *)applyWithComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser:(ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser * __nonnull)closer
                                                                                                            withId:(id __nullable)value1
                                                                                                            withId:(id __nullable)value2
                                                                                                            withId:(id __nullable)value3
                                                                                                            withId:(id __nullable)value4;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_Combiner4_AsyncClosingFunction4)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_Combiner4_AsyncClosingFunction4)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_Combiner5_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner5))
#define ComGoogleCommonUtilConcurrentClosingFuture_Combiner5_

@class ComGoogleCommonUtilConcurrentClosingFuture;
@protocol ComGoogleCommonUtilConcurrentClosingFuture_Combiner5_AsyncClosingFunction5;
@protocol ComGoogleCommonUtilConcurrentClosingFuture_Combiner5_ClosingFunction5;
@protocol JavaUtilConcurrentExecutor;

/*!
 @brief A generic <code>Combiner</code> that lets you use a lambda or method reference to combine five 
 <code>ClosingFuture</code>s.Use <code>whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture,
 ClosingFuture, ClosingFuture)</code>
  to start this combination.
 */
@interface ComGoogleCommonUtilConcurrentClosingFuture_Combiner5 : ComGoogleCommonUtilConcurrentClosingFuture_Combiner

#pragma mark Public

/*!
 @brief Returns a new <code>ClosingFuture</code> pipeline step derived from the inputs by applying a
  combining function to their values.The function can use a <code>DeferredCloser</code> to capture
  objects to be closed when the pipeline is done.
 <p>If this combiner was returned by <code>whenAllSucceed(ClosingFuture, ClosingFuture,
 ClosingFuture, ClosingFuture, ClosingFuture)</code>
  and any of the inputs fail, so will the
  returned step. 
 <p>If the function throws a <code>CancellationException</code>, the pipeline will be cancelled. 
 <p>If the function throws an <code>ExecutionException</code>, the cause of the thrown <code>ExecutionException</code>
  will be extracted and used as the failure of the derived step.
 */
- (ComGoogleCommonUtilConcurrentClosingFuture *)callWithComGoogleCommonUtilConcurrentClosingFuture_Combiner5_ClosingFunction5:(id<ComGoogleCommonUtilConcurrentClosingFuture_Combiner5_ClosingFunction5> __nonnull)function
                                                                                               withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

/*!
 @brief Returns a new <code>ClosingFuture</code> pipeline step derived from the inputs by applying a 
 <code>ClosingFuture</code>-returning function to their values.The function can use a <code>DeferredCloser</code>
  to capture objects to be closed when the pipeline is done (other than those
  captured by the returned <code>ClosingFuture</code>).
 <p>If this combiner was returned by <code>whenAllSucceed(ClosingFuture, ClosingFuture,
 ClosingFuture, ClosingFuture, ClosingFuture)</code>
  and any of the inputs fail, so will the
  returned step. 
 <p>If the function throws a <code>CancellationException</code>, the pipeline will be cancelled. 
 <p>If the function throws an <code>ExecutionException</code>, the cause of the thrown <code>ExecutionException</code>
  will be extracted and used as the failure of the derived step. 
 <p>If the function throws any other exception, it will be used as the failure of the derived
  step. 
 <p>If an exception is thrown after the function creates a <code>ClosingFuture</code>, then none of
  the closeable objects in that <code>ClosingFuture</code> will be closed. 
 <p>Usage guidelines for this method: 
 <ul>
    <li>Use this method only when calling an API that returns a <code>ListenableFuture</code> or a
        <code>ClosingFuture</code>. If possible, prefer calling <code>call(CombiningCallable,
       Executor)</code>
  instead, with a function that returns the next value directly.
    <li>Call <code>closer.eventuallyClose()</code>
  for every closeable object this step creates in order to
        capture it for later closing.   
 <li>Return a <code>ClosingFuture</code>. To turn a <code>ListenableFuture</code> into a <code>ClosingFuture</code>
  call <code>from(ListenableFuture)</code>.
  </ul>
  
 <p>The same warnings about doing heavyweight operations within <code>ClosingFuture.transformAsync(AsyncClosingFunction, Executor)</code>
  apply here.
 */
- (ComGoogleCommonUtilConcurrentClosingFuture *)callAsyncWithComGoogleCommonUtilConcurrentClosingFuture_Combiner5_AsyncClosingFunction5:(id<ComGoogleCommonUtilConcurrentClosingFuture_Combiner5_AsyncClosingFunction5> __nonnull)function
                                                                                                         withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor> __nonnull)executor;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_Combiner5)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_Combiner5)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_Combiner5_ClosingFunction5_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner5_ClosingFunction5))
#define ComGoogleCommonUtilConcurrentClosingFuture_Combiner5_ClosingFunction5_

@class ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser;

/*!
 @brief A function that returns a value when applied to the values of the five futures passed to 
 <code>whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture, ClosingFuture,
 ClosingFuture)</code>
 .
 */
@protocol ComGoogleCommonUtilConcurrentClosingFuture_Combiner5_ClosingFunction5 < JavaObject >

/*!
 @brief Applies this function to five inputs, or throws an exception if unable to do so.
 <p>Any objects that are passed to <code>closer.eventuallyClose()</code>
  will be closed when the <code>ClosingFuture</code> pipeline
  is done (but not before this method completes), even if this method throws or the pipeline
  is cancelled.
 */
- (id __nullable)applyWithComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser:(ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser * __nonnull)closer
                                                                             withId:(id __nullable)value1
                                                                             withId:(id __nullable)value2
                                                                             withId:(id __nullable)value3
                                                                             withId:(id __nullable)value4
                                                                             withId:(id __nullable)value5;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_Combiner5_ClosingFunction5)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_Combiner5_ClosingFunction5)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_Combiner5_AsyncClosingFunction5_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_Combiner5_AsyncClosingFunction5))
#define ComGoogleCommonUtilConcurrentClosingFuture_Combiner5_AsyncClosingFunction5_

@class ComGoogleCommonUtilConcurrentClosingFuture;
@class ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser;

/*!
 @brief A function that returns a <code>ClosingFuture</code> when applied to the values of the five
  futures passed to <code>whenAllSucceed(ClosingFuture, ClosingFuture, ClosingFuture,
 ClosingFuture, ClosingFuture)</code>
 .
 */
@protocol ComGoogleCommonUtilConcurrentClosingFuture_Combiner5_AsyncClosingFunction5 < JavaObject >

/*!
 @brief Applies this function to five inputs, or throws an exception if unable to do so.
 <p>Any objects that are passed to <code>closer.eventuallyClose()</code>
  will be closed when the <code>ClosingFuture</code> pipeline
  is done (but not before this method completes), even if this method throws or the pipeline
  is cancelled.
 */
- (ComGoogleCommonUtilConcurrentClosingFuture *)applyWithComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser:(ComGoogleCommonUtilConcurrentClosingFuture_DeferredCloser * __nonnull)closer
                                                                                                            withId:(id __nullable)value1
                                                                                                            withId:(id __nullable)value2
                                                                                                            withId:(id __nullable)value3
                                                                                                            withId:(id __nullable)value4
                                                                                                            withId:(id __nullable)value5;

@end

J2OBJC_EMPTY_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_Combiner5_AsyncClosingFunction5)

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_Combiner5_AsyncClosingFunction5)

#endif

#if !defined (ComGoogleCommonUtilConcurrentClosingFuture_State_) && (INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture || defined(INCLUDE_ComGoogleCommonUtilConcurrentClosingFuture_State))
#define ComGoogleCommonUtilConcurrentClosingFuture_State_

#define RESTRICT_JavaLangEnum 1
#define INCLUDE_JavaLangEnum 1
#include "java/lang/Enum.h"

@class IOSObjectArray;

typedef NS_ENUM(NSUInteger, ComGoogleCommonUtilConcurrentClosingFuture_State_Enum) {
  ComGoogleCommonUtilConcurrentClosingFuture_State_Enum_OPEN = 0,
  ComGoogleCommonUtilConcurrentClosingFuture_State_Enum_SUBSUMED = 1,
  ComGoogleCommonUtilConcurrentClosingFuture_State_Enum_WILL_CLOSE = 2,
  ComGoogleCommonUtilConcurrentClosingFuture_State_Enum_CLOSING = 3,
  ComGoogleCommonUtilConcurrentClosingFuture_State_Enum_CLOSED = 4,
  ComGoogleCommonUtilConcurrentClosingFuture_State_Enum_WILL_CREATE_VALUE_AND_CLOSER = 5,
};

/*!
 @brief The state of a <code>CloseableList</code>.
 */
@interface ComGoogleCommonUtilConcurrentClosingFuture_State : JavaLangEnum

@property (readonly, class, nonnull) ComGoogleCommonUtilConcurrentClosingFuture_State *OPEN NS_SWIFT_NAME(OPEN);
@property (readonly, class, nonnull) ComGoogleCommonUtilConcurrentClosingFuture_State *SUBSUMED NS_SWIFT_NAME(SUBSUMED);
@property (readonly, class, nonnull) ComGoogleCommonUtilConcurrentClosingFuture_State *WILL_CLOSE NS_SWIFT_NAME(WILL_CLOSE);
@property (readonly, class, nonnull) ComGoogleCommonUtilConcurrentClosingFuture_State *CLOSING NS_SWIFT_NAME(CLOSING);
@property (readonly, class, nonnull) ComGoogleCommonUtilConcurrentClosingFuture_State *CLOSED NS_SWIFT_NAME(CLOSED);
@property (readonly, class, nonnull) ComGoogleCommonUtilConcurrentClosingFuture_State *WILL_CREATE_VALUE_AND_CLOSER NS_SWIFT_NAME(WILL_CREATE_VALUE_AND_CLOSER);
#pragma mark Public

+ (ComGoogleCommonUtilConcurrentClosingFuture_State *)valueOfWithNSString:(NSString * __nonnull)name;

+ (IOSObjectArray *)values;

#pragma mark Package-Private

- (ComGoogleCommonUtilConcurrentClosingFuture_State_Enum)toNSEnum;

@end

J2OBJC_STATIC_INIT(ComGoogleCommonUtilConcurrentClosingFuture_State)

/*! INTERNAL ONLY - Use enum accessors declared below. */
FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentClosingFuture_State *ComGoogleCommonUtilConcurrentClosingFuture_State_values_[];

/*!
 @brief The <code>CloseableList</code> has not been subsumed or closed.
 */
inline ComGoogleCommonUtilConcurrentClosingFuture_State *ComGoogleCommonUtilConcurrentClosingFuture_State_get_OPEN(void);
J2OBJC_ENUM_CONSTANT(ComGoogleCommonUtilConcurrentClosingFuture_State, OPEN)

/*!
 @brief The <code>CloseableList</code> has been subsumed into another.It may not be closed or subsumed
  into any other.
 */
inline ComGoogleCommonUtilConcurrentClosingFuture_State *ComGoogleCommonUtilConcurrentClosingFuture_State_get_SUBSUMED(void);
J2OBJC_ENUM_CONSTANT(ComGoogleCommonUtilConcurrentClosingFuture_State, SUBSUMED)

/*!
 @brief Some <code>ListenableFuture</code> has a callback attached that will close the <code>CloseableList</code>
 , but it has not yet run.The <code>CloseableList</code> may not be subsumed.
 */
inline ComGoogleCommonUtilConcurrentClosingFuture_State *ComGoogleCommonUtilConcurrentClosingFuture_State_get_WILL_CLOSE(void);
J2OBJC_ENUM_CONSTANT(ComGoogleCommonUtilConcurrentClosingFuture_State, WILL_CLOSE)

/*!
 @brief The callback that closes the <code>CloseableList</code> is running, but it has not completed.The
  <code>CloseableList</code> may not be subsumed.
 */
inline ComGoogleCommonUtilConcurrentClosingFuture_State *ComGoogleCommonUtilConcurrentClosingFuture_State_get_CLOSING(void);
J2OBJC_ENUM_CONSTANT(ComGoogleCommonUtilConcurrentClosingFuture_State, CLOSING)

/*!
 @brief The <code>CloseableList</code> has been closed.It may not be further subsumed.
 */
inline ComGoogleCommonUtilConcurrentClosingFuture_State *ComGoogleCommonUtilConcurrentClosingFuture_State_get_CLOSED(void);
J2OBJC_ENUM_CONSTANT(ComGoogleCommonUtilConcurrentClosingFuture_State, CLOSED)

/*!
 @brief <code>ClosingFuture.finishToValueAndCloser(ValueAndCloserConsumer, Executor)</code> has been
  called.The step may not be further subsumed, nor may <code>finishToFuture()</code> be called.
 */
inline ComGoogleCommonUtilConcurrentClosingFuture_State *ComGoogleCommonUtilConcurrentClosingFuture_State_get_WILL_CREATE_VALUE_AND_CLOSER(void);
J2OBJC_ENUM_CONSTANT(ComGoogleCommonUtilConcurrentClosingFuture_State, WILL_CREATE_VALUE_AND_CLOSER)

FOUNDATION_EXPORT IOSObjectArray *ComGoogleCommonUtilConcurrentClosingFuture_State_values(void);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentClosingFuture_State *ComGoogleCommonUtilConcurrentClosingFuture_State_valueOfWithNSString_(NSString *name);

FOUNDATION_EXPORT ComGoogleCommonUtilConcurrentClosingFuture_State *ComGoogleCommonUtilConcurrentClosingFuture_State_fromOrdinal(NSUInteger ordinal);

J2OBJC_TYPE_LITERAL_HEADER(ComGoogleCommonUtilConcurrentClosingFuture_State)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_ComGoogleCommonUtilConcurrentClosingFuture")
