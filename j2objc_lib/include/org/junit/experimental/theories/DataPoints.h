//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/junit/build_result/java/org/junit/experimental/theories/DataPoints.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgJunitExperimentalTheoriesDataPoints")
#ifdef RESTRICT_OrgJunitExperimentalTheoriesDataPoints
#define INCLUDE_ALL_OrgJunitExperimentalTheoriesDataPoints 0
#else
#define INCLUDE_ALL_OrgJunitExperimentalTheoriesDataPoints 1
#endif
#undef RESTRICT_OrgJunitExperimentalTheoriesDataPoints

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (OrgJunitExperimentalTheoriesDataPoints_) && (INCLUDE_ALL_OrgJunitExperimentalTheoriesDataPoints || defined(INCLUDE_OrgJunitExperimentalTheoriesDataPoints))
#define OrgJunitExperimentalTheoriesDataPoints_

#define RESTRICT_JavaLangAnnotationAnnotation 1
#define INCLUDE_JavaLangAnnotationAnnotation 1
#include "java/lang/annotation/Annotation.h"

@class IOSClass;
@class IOSObjectArray;

/*!
 @brief Annotating an array or iterable-typed field or method with &#064;DataPoints
  will cause the values in the array or iterable given to be used as potential
  parameters for theories in that class when run with the 
 <code>Theories</code> runner.
 <p>
  DataPoints will only be considered as potential values for parameters for
  which their types are assignable. When multiple sets of DataPoints exist with
  overlapping types more control can be obtained by naming the DataPoints using
  the value of this annotation, e.g. with 
 <code>&#064;DataPoints({"dataset1", "dataset2"})</code>, and then specifying
  which named set to consider as potential values for each parameter using the 
 <code>&.064;FromDataPoints</code>
  annotation. 
 <p>
  Parameters with no specified source (i.e. without &#064;FromDataPoints or
  other <code>&.064;ParameterSuppliedBy</code>
  annotations) will use all DataPoints that are
  assignable to the parameter type as potential values, including named sets of
  DataPoints. 
 <p>
  DataPoints methods whose array types aren't assignable from the target
  parameter type (and so can't possibly return relevant values) will not be
  called when generating values for that parameter. Iterable-typed datapoints
  methods must always be called though, as this information is not available
  here after generic type erasure, so expensive methods returning iterable
  datapoints are a bad idea.  
 @code

   &#064;DataPoints
  public static String[] dataPoints = new String[] { ... };  
  &#064;DataPoints
  public static String[] generatedDataPoints() {
      return new String[] { ... }; }  
  &#064;Theory
  public void theoryMethod(String param) {
      ...
  } 
  
@endcode
 - seealso: org.junit.experimental.theories.Theories
 - seealso: org.junit.experimental.theories.Theory
 - seealso: org.junit.experimental.theories.DataPoint
 - seealso: org.junit.experimental.theories.FromDataPoints
 */
@protocol OrgJunitExperimentalTheoriesDataPoints < JavaLangAnnotationAnnotation >

@property (readonly) IOSObjectArray *value;
@property (readonly) IOSObjectArray *ignoredExceptions;

- (jboolean)isEqual:(id)obj;

- (NSUInteger)hash;

@end

@interface OrgJunitExperimentalTheoriesDataPoints : NSObject < OrgJunitExperimentalTheoriesDataPoints > {
 @public
  IOSObjectArray *value_;
  IOSObjectArray *ignoredExceptions_;
}

@end

J2OBJC_EMPTY_STATIC_INIT(OrgJunitExperimentalTheoriesDataPoints)

FOUNDATION_EXPORT id<OrgJunitExperimentalTheoriesDataPoints> create_OrgJunitExperimentalTheoriesDataPoints(IOSObjectArray *ignoredExceptions, IOSObjectArray *value);

J2OBJC_TYPE_LITERAL_HEADER(OrgJunitExperimentalTheoriesDataPoints)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_OrgJunitExperimentalTheoriesDataPoints")
