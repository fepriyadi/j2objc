//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/src/j2objc/junit/build_result/java/org/junit/runners/Parameterized.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgJunitRunnersParameterized")
#ifdef RESTRICT_OrgJunitRunnersParameterized
#define INCLUDE_ALL_OrgJunitRunnersParameterized 0
#else
#define INCLUDE_ALL_OrgJunitRunnersParameterized 1
#endif
#undef RESTRICT_OrgJunitRunnersParameterized

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (OrgJunitRunnersParameterized_) && (INCLUDE_ALL_OrgJunitRunnersParameterized || defined(INCLUDE_OrgJunitRunnersParameterized))
#define OrgJunitRunnersParameterized_

#define RESTRICT_OrgJunitRunnersSuite 1
#define INCLUDE_OrgJunitRunnersSuite 1
#include "org/junit/runners/Suite.h"

@class IOSClass;
@class IOSObjectArray;
@class OrgJunitRunnersModelRunnerBuilder;
@protocol JavaUtilList;

/*!
 @brief The custom runner <code>Parameterized</code> implements parameterized tests.
 When running a parameterized test class, instances are created for the
  cross-product of the test methods and the test data elements. 
 <p>
  For example, to test the <code>+</code> operator, write: 
 @code

   &#064;RunWith(Parameterized.class)
  public class AdditionTest {
          &#064;Parameters(name = &quot;{index}: {0} + {1} = {2}&quot;)
      public static Iterable&lt;Object[]&gt; data() {
          return Arrays.asList(new Object[][] { { 0, 0, 0 }, { 1, 1, 2 },
                  { 3, 2, 5 }, { 4, 3, 7 } });
      }
      private int firstSummand;
      private int secondSummand;
      private int sum;
      public AdditionTest(int firstSummand, int secondSummand, int sum) {
          this.firstSummand = firstSummand;
          this.secondSummand = secondSummand;
          this.sum = sum;
      }     
     &#064;Test
      public void test() {
          assertEquals(sum, firstSummand + secondSummand);
      }    }    
  
@endcode
  <p>
  Each instance of <code>AdditionTest</code> will be constructed using the
  three-argument constructor and the data values in the 
 <code>&#064;Parameters</code> method. 
 <p>
  In order that you can easily identify the individual tests, you may provide a
  name for the <code>&#064;Parameters</code> annotation. This name is allowed
  to contain placeholders, which are replaced at runtime. The placeholders are 
 <dl>
  <dt>{index}</dt>
  <dd>the current parameter index</dd>
  <dt>{0}</dt>
  <dd>the first parameter value</dd>
  <dt>{1}</dt>
  <dd>the second parameter value</dd>
  <dt>...</dt>
  <dd>...</dd>
  </dl>
  <p>
  In the example given above, the <code>Parameterized</code> runner creates
  names like <code>[2: 3 + 2 = 5]</code>. If you don't use the name parameter,
  then the current parameter index is used as name. 
 <p>
  You can also write: 
 @code

   &#064;RunWith(Parameterized.class)
  public class AdditionTest {
          &#064;Parameters(name = &quot;{index}: {0} + {1} = {2}&quot;)
      public static Iterable&lt;Object[]&gt; data() {
          return Arrays.asList(new Object[][] { { 0, 0, 0 }, { 1, 1, 2 },
                  { 3, 2, 5 }, { 4, 3, 7 } });
      }     
     &#064;Parameter(0)
      public int firstSummand;     
     &#064;Parameter(1)
      public int secondSummand;     
     &#064;Parameter(2)
      public int sum;     
     &#064;Test
      public void test() {
          assertEquals(sum, firstSummand + secondSummand);
      }    }    
  
@endcode
  <p>
  Each instance of <code>AdditionTest</code> will be constructed with the default constructor
  and fields annotated by <code>&#064;Parameter</code>  will be initialized
  with the data values in the <code>&#064;Parameters</code> method. 
 <p>
  The parameters can be provided as an array, too:  
 @code

   &#064;Parameters
  public static Object[][] data() {
  	return new Object[][] { { 0, 0, 0 }, { 1, 1, 2 }, { 3, 2, 5 }, { 4, 3, 7 } } }; } 
  
@endcode
   
 <h3>Tests with single parameter</h3>
  <p>
  If your test needs a single parameter only, you don't have to wrap it with an
  array. Instead you can provide an <code>Iterable</code> or an array of
  objects. 
 @code

   &#064;Parameters
  public static Iterable&lt;? extends Object&gt; data() {
  	return Arrays.asList(&quot;first test&quot;, &quot;second test&quot;);
  } 
  
@endcode
  <p>
  or 
 @code

   &#064;Parameters
  public static Object[] data() {
  	return new Object[] { &quot;first test&quot;, &quot;second test&quot; }; } 
  
@endcode
  
 <h3>Executing code before/after executing tests for specific parameters</h3>
  <p>
  If your test needs to perform some preparation or cleanup based on the
  parameters, this can be done by adding public static methods annotated with 
 <code>@@BeforeParam</code>/<code>@@AfterParam</code>. Such methods should either have no
  parameters or the same parameters as the test. 
 @code

   &#064;BeforeParam
  public static void beforeTestsForParameter(String onlyParameter) {
      System.out.println("Testing " + onlyParameter);
  } 
  
@endcode
  
 <h3>Create different runners</h3>
  <p>
  By default the <code>Parameterized</code> runner creates a slightly modified 
 <code>BlockJUnit4ClassRunner</code> for each set of parameters. You can build an
  own <code>Parameterized</code> runner that creates another runner for each set of
  parameters. Therefore you have to build a <code>ParametersRunnerFactory</code>
  that creates a runner for each <code>TestWithParameters</code>. ( 
 <code>TestWithParameters</code> are bundling the parameters and the test name.)
  The factory must have a public zero-arg constructor. 
 @code

  public class YourRunnerFactory implements ParametersRunnerFactory {
      public Runner createRunnerForTestWithParameters(TestWithParameters test)
              throws InitializationError {
          return YourRunner(test);
      }    }    
  
@endcode
  <p>
  Use the <code>UseParametersRunnerFactory</code> to tell the <code>Parameterized</code>
  runner that it should use your factory. 
 @code

   &#064;RunWith(Parameterized.class)
   &#064;UseParametersRunnerFactory(YourRunnerFactory.class)
  public class YourTest {
      ...
  } 
  
@endcode
  
 <h3>Avoid creating parameters</h3>
  <p>With <code>assumptions</code> you can dynamically skip tests.
  Assumptions are also supported by the <code>&#064;Parameters</code> method.
  Creating parameters is stopped when the assumption fails and none of the
  tests in the test class is executed. JUnit reports a 
 <code>single assumption failure</code> for the
  whole test class in this case. 
 @code

   &#064;Parameters
  public static Iterable&lt;? extends Object&gt; data() {
  	String os = System.getProperty("os.name").toLowerCase()
  	Assume.assumeTrue(os.contains("win"));
  	return Arrays.asList(&quot;first test&quot;, &quot;second test&quot;);
  } 
  
@endcode
 @since 4.0
 */
@interface OrgJunitRunnersParameterized : OrgJunitRunnersSuite

#pragma mark Public

/*!
 @brief Only called reflectively.Do not use programmatically.
 */
- (instancetype __nonnull)initWithIOSClass:(IOSClass *)klass;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithIOSClass:(IOSClass *)arg0
                         withIOSClassArray:(IOSObjectArray *)arg1 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithIOSClass:(IOSClass *)arg0
                          withJavaUtilList:(id<JavaUtilList>)arg1 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithIOSClass:(IOSClass *)arg0
     withOrgJunitRunnersModelRunnerBuilder:(OrgJunitRunnersModelRunnerBuilder *)arg1 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithOrgJunitRunnersModelRunnerBuilder:(OrgJunitRunnersModelRunnerBuilder *)arg0
                                                       withIOSClass:(IOSClass *)arg1
                                                  withIOSClassArray:(IOSObjectArray *)arg2 NS_UNAVAILABLE;

- (instancetype __nonnull)initWithOrgJunitRunnersModelRunnerBuilder:(OrgJunitRunnersModelRunnerBuilder *)arg0
                                                  withIOSClassArray:(IOSObjectArray *)arg1 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgJunitRunnersParameterized)

FOUNDATION_EXPORT void OrgJunitRunnersParameterized_initWithIOSClass_(OrgJunitRunnersParameterized *self, IOSClass *klass);

FOUNDATION_EXPORT OrgJunitRunnersParameterized *new_OrgJunitRunnersParameterized_initWithIOSClass_(IOSClass *klass) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgJunitRunnersParameterized *create_OrgJunitRunnersParameterized_initWithIOSClass_(IOSClass *klass);

J2OBJC_TYPE_LITERAL_HEADER(OrgJunitRunnersParameterized)

#endif

#if !defined (OrgJunitRunnersParameterized_Parameters_) && (INCLUDE_ALL_OrgJunitRunnersParameterized || defined(INCLUDE_OrgJunitRunnersParameterized_Parameters))
#define OrgJunitRunnersParameterized_Parameters_

#define RESTRICT_JavaLangAnnotationAnnotation 1
#define INCLUDE_JavaLangAnnotationAnnotation 1
#include "java/lang/annotation/Annotation.h"

@class IOSClass;

/*!
 @brief Annotation for a method which provides parameters to be injected into the
  test class constructor by <code>Parameterized</code>.The method has to
  be public and static.
 */
@protocol OrgJunitRunnersParameterized_Parameters < JavaLangAnnotationAnnotation >

@property (readonly) NSString *name;

- (jboolean)isEqual:(id)obj;

- (NSUInteger)hash;

@end

@interface OrgJunitRunnersParameterized_Parameters : NSObject < OrgJunitRunnersParameterized_Parameters > {
 @public
  NSString *name_;
}

@end

J2OBJC_EMPTY_STATIC_INIT(OrgJunitRunnersParameterized_Parameters)

FOUNDATION_EXPORT id<OrgJunitRunnersParameterized_Parameters> create_OrgJunitRunnersParameterized_Parameters(NSString *name);

J2OBJC_TYPE_LITERAL_HEADER(OrgJunitRunnersParameterized_Parameters)

#endif

#if !defined (OrgJunitRunnersParameterized_Parameter_) && (INCLUDE_ALL_OrgJunitRunnersParameterized || defined(INCLUDE_OrgJunitRunnersParameterized_Parameter))
#define OrgJunitRunnersParameterized_Parameter_

#define RESTRICT_JavaLangAnnotationAnnotation 1
#define INCLUDE_JavaLangAnnotationAnnotation 1
#include "java/lang/annotation/Annotation.h"

@class IOSClass;

/*!
 @brief Annotation for fields of the test class which will be initialized by the
  method annotated by <code>Parameters</code>.
 By using directly this annotation, the test class constructor isn't needed.
  Index range must start at 0.
  Default value is 0.
 */
@protocol OrgJunitRunnersParameterized_Parameter < JavaLangAnnotationAnnotation >

@property (readonly) jint value;

- (jboolean)isEqual:(id)obj;

- (NSUInteger)hash;

@end

@interface OrgJunitRunnersParameterized_Parameter : NSObject < OrgJunitRunnersParameterized_Parameter > {
 @public
  jint value_;
}

@end

J2OBJC_EMPTY_STATIC_INIT(OrgJunitRunnersParameterized_Parameter)

FOUNDATION_EXPORT id<OrgJunitRunnersParameterized_Parameter> create_OrgJunitRunnersParameterized_Parameter(jint value);

J2OBJC_TYPE_LITERAL_HEADER(OrgJunitRunnersParameterized_Parameter)

#endif

#if !defined (OrgJunitRunnersParameterized_UseParametersRunnerFactory_) && (INCLUDE_ALL_OrgJunitRunnersParameterized || defined(INCLUDE_OrgJunitRunnersParameterized_UseParametersRunnerFactory))
#define OrgJunitRunnersParameterized_UseParametersRunnerFactory_

#define RESTRICT_JavaLangAnnotationAnnotation 1
#define INCLUDE_JavaLangAnnotationAnnotation 1
#include "java/lang/annotation/Annotation.h"

@class IOSClass;

/*!
 @brief Add this annotation to your test class if you want to generate a special
  runner.You have to specify a <code>ParametersRunnerFactory</code> class that
  creates such runners.
 The factory must have a public zero-arg
  constructor.
 */
@protocol OrgJunitRunnersParameterized_UseParametersRunnerFactory < JavaLangAnnotationAnnotation >

@property (readonly) IOSClass *value;

- (jboolean)isEqual:(id)obj;

- (NSUInteger)hash;

@end

@interface OrgJunitRunnersParameterized_UseParametersRunnerFactory : NSObject < OrgJunitRunnersParameterized_UseParametersRunnerFactory > {
 @public
  IOSClass *value_;
}

@end

J2OBJC_EMPTY_STATIC_INIT(OrgJunitRunnersParameterized_UseParametersRunnerFactory)

FOUNDATION_EXPORT id<OrgJunitRunnersParameterized_UseParametersRunnerFactory> create_OrgJunitRunnersParameterized_UseParametersRunnerFactory(IOSClass *value);

J2OBJC_TYPE_LITERAL_HEADER(OrgJunitRunnersParameterized_UseParametersRunnerFactory)

#endif

#if !defined (OrgJunitRunnersParameterized_BeforeParam_) && (INCLUDE_ALL_OrgJunitRunnersParameterized || defined(INCLUDE_OrgJunitRunnersParameterized_BeforeParam))
#define OrgJunitRunnersParameterized_BeforeParam_

#define RESTRICT_JavaLangAnnotationAnnotation 1
#define INCLUDE_JavaLangAnnotationAnnotation 1
#include "java/lang/annotation/Annotation.h"

@class IOSClass;

/*!
 @brief Annotation for <code>public static void</code> methods which should be executed before
  evaluating tests with particular parameters.
 - seealso: org.junit.BeforeClass
 - seealso: org.junit.Before
 @since 4.13
 */
@protocol OrgJunitRunnersParameterized_BeforeParam < JavaLangAnnotationAnnotation >

- (jboolean)isEqual:(id)obj;

- (NSUInteger)hash;

@end

@interface OrgJunitRunnersParameterized_BeforeParam : NSObject < OrgJunitRunnersParameterized_BeforeParam >

@end

J2OBJC_EMPTY_STATIC_INIT(OrgJunitRunnersParameterized_BeforeParam)

FOUNDATION_EXPORT id<OrgJunitRunnersParameterized_BeforeParam> create_OrgJunitRunnersParameterized_BeforeParam(void);

J2OBJC_TYPE_LITERAL_HEADER(OrgJunitRunnersParameterized_BeforeParam)

#endif

#if !defined (OrgJunitRunnersParameterized_AfterParam_) && (INCLUDE_ALL_OrgJunitRunnersParameterized || defined(INCLUDE_OrgJunitRunnersParameterized_AfterParam))
#define OrgJunitRunnersParameterized_AfterParam_

#define RESTRICT_JavaLangAnnotationAnnotation 1
#define INCLUDE_JavaLangAnnotationAnnotation 1
#include "java/lang/annotation/Annotation.h"

@class IOSClass;

/*!
 @brief Annotation for <code>public static void</code> methods which should be executed after
  evaluating tests with particular parameters.
 - seealso: org.junit.AfterClass
 - seealso: org.junit.After
 @since 4.13
 */
@protocol OrgJunitRunnersParameterized_AfterParam < JavaLangAnnotationAnnotation >

- (jboolean)isEqual:(id)obj;

- (NSUInteger)hash;

@end

@interface OrgJunitRunnersParameterized_AfterParam : NSObject < OrgJunitRunnersParameterized_AfterParam >

@end

J2OBJC_EMPTY_STATIC_INIT(OrgJunitRunnersParameterized_AfterParam)

FOUNDATION_EXPORT id<OrgJunitRunnersParameterized_AfterParam> create_OrgJunitRunnersParameterized_AfterParam(void);

J2OBJC_TYPE_LITERAL_HEADER(OrgJunitRunnersParameterized_AfterParam)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif

#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_OrgJunitRunnersParameterized")
